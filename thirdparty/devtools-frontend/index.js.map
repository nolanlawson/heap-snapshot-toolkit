{"version":3,"file":"index.js","sources":["../../../../../devtools-frontend/front_end/models/heap_snapshot_model/HeapSnapshotModel.ts","../../../../../devtools-frontend/front_end/entrypoints/heap_snapshot_worker/AllocationProfile.ts","../../../../../devtools-frontend/front_end/core/i18n/DevToolsLocale.ts","../../../../../devtools-frontend/front_end/third_party/i18n/localized-string-set.ts","../../../../../devtools-frontend/front_end/third_party/i18n/i18n-impl.ts","../../../../../devtools-frontend/front_end/core/platform/ArrayUtilities.ts","../../../../../devtools-frontend/front_end/core/platform/MapUtilities.ts","../../../../../devtools-frontend/front_end/core/platform/StringUtilities.ts","../../../../../devtools-frontend/front_end/core/platform/TypedArrayUtilities.ts","../../../../../devtools-frontend/front_end/core/root/Runtime.ts","../../../../../devtools-frontend/front_end/core/i18n/i18nImpl.ts","../../../../../devtools-frontend/front_end/entrypoints/heap_snapshot_worker/HeapSnapshot.ts","../../../../../devtools-frontend/front_end/models/text_utils/TextUtils.ts","../../../../../devtools-frontend/front_end/core/common/Base64.ts","../../../../../devtools-frontend/front_end/core/common/Revealer.ts","../../../../../devtools-frontend/front_end/core/common/Console.ts","../../../../../devtools-frontend/front_end/core/common/SettingRegistration.ts","../../../../../devtools-frontend/front_end/entrypoints/heap_snapshot_worker/HeapSnapshotLoader.ts"],"sourcesContent":["/*\n * Copyright (C) 2014 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nexport const HeapSnapshotProgressEvent = {\n  Update: 'ProgressUpdate',\n  BrokenSnapshot: 'BrokenSnapshot',\n};\n\nexport const baseSystemDistance = 100000000;\nexport const baseUnreachableDistance = baseSystemDistance * 2;\n\nexport class AllocationNodeCallers {\n  nodesWithSingleCaller: SerializedAllocationNode[];\n  branchingCallers: SerializedAllocationNode[];\n  constructor(nodesWithSingleCaller: SerializedAllocationNode[], branchingCallers: SerializedAllocationNode[]) {\n    this.nodesWithSingleCaller = nodesWithSingleCaller;\n    this.branchingCallers = branchingCallers;\n  }\n}\n\nexport class SerializedAllocationNode {\n  id: number;\n  name: string;\n  scriptName: string;\n  scriptId: number;\n  line: number;\n  column: number;\n  count: number;\n  size: number;\n  liveCount: number;\n  liveSize: number;\n  hasChildren: boolean;\n  constructor(\n      nodeId: number, functionName: string, scriptName: string, scriptId: number, line: number, column: number,\n      count: number, size: number, liveCount: number, liveSize: number, hasChildren: boolean) {\n    this.id = nodeId;\n    this.name = functionName;\n    this.scriptName = scriptName;\n    this.scriptId = scriptId;\n    this.line = line;\n    this.column = column;\n    this.count = count;\n    this.size = size;\n    this.liveCount = liveCount;\n    this.liveSize = liveSize;\n    this.hasChildren = hasChildren;\n  }\n}\n\nexport class AllocationStackFrame {\n  functionName: string;\n  scriptName: string;\n  scriptId: number;\n  line: number;\n  column: number;\n  constructor(functionName: string, scriptName: string, scriptId: number, line: number, column: number) {\n    this.functionName = functionName;\n    this.scriptName = scriptName;\n    this.scriptId = scriptId;\n    this.line = line;\n    this.column = column;\n  }\n}\n\nexport class Node {\n  id: number;\n  name: string;\n  distance: number;\n  nodeIndex: number;\n  retainedSize: number;\n  selfSize: number;\n  type: string;\n  canBeQueried: boolean;\n  detachedDOMTreeNode: boolean;\n  isAddedNotRemoved: boolean|null;\n  ignored: boolean;\n  constructor(\n      id: number, name: string, distance: number, nodeIndex: number, retainedSize: number, selfSize: number,\n      type: string) {\n    this.id = id;\n    this.name = name;\n    this.distance = distance;\n    this.nodeIndex = nodeIndex;\n    this.retainedSize = retainedSize;\n    this.selfSize = selfSize;\n    this.type = type;\n\n    this.canBeQueried = false;\n    this.detachedDOMTreeNode = false;\n    this.isAddedNotRemoved = null;\n    this.ignored = false;\n  }\n}\n\nexport class Edge {\n  name: string;\n  node: Node;\n  type: string;\n  edgeIndex: number;\n  isAddedNotRemoved: boolean|null;\n  constructor(name: string, node: Node, type: string, edgeIndex: number) {\n    this.name = name;\n    this.node = node;\n    this.type = type;\n    this.edgeIndex = edgeIndex;\n    this.isAddedNotRemoved = null;\n  }\n}\n\nexport class Aggregate {\n  count!: number;\n  distance!: number;\n  self!: number;\n  maxRet!: number;\n  name!: string;\n  idxs!: number[];\n}\n\nexport class AggregateForDiff {\n  name: string;\n  indexes: number[];\n  ids: number[];\n  selfSizes: number[];\n  constructor() {\n    this.name = '';\n    this.indexes = [];\n    this.ids = [];\n    this.selfSizes = [];\n  }\n}\n\nexport class Diff {\n  name: string;\n  addedCount: number;\n  removedCount: number;\n  addedSize: number;\n  removedSize: number;\n  deletedIndexes: number[];\n  addedIndexes: number[];\n  countDelta!: number;\n  sizeDelta!: number;\n  constructor(name: string) {\n    this.name = name;\n    this.addedCount = 0;\n    this.removedCount = 0;\n    this.addedSize = 0;\n    this.removedSize = 0;\n    this.deletedIndexes = [];\n    this.addedIndexes = [];\n  }\n}\n\nexport class DiffForClass {\n  name!: string;\n  addedCount!: number;\n  removedCount!: number;\n  addedSize!: number;\n  removedSize!: number;\n  deletedIndexes!: number[];\n  addedIndexes!: number[];\n  countDelta!: number;\n  sizeDelta!: number;\n}\n\nexport class ComparatorConfig {\n  fieldName1: string;\n  ascending1: boolean;\n  fieldName2: string;\n  ascending2: boolean;\n  constructor(fieldName1: string, ascending1: boolean, fieldName2: string, ascending2: boolean) {\n    this.fieldName1 = fieldName1;\n    this.ascending1 = ascending1;\n    this.fieldName2 = fieldName2;\n    this.ascending2 = ascending2;\n  }\n}\n\nexport class WorkerCommand {\n  callId!: number;\n  disposition!: string;\n  objectId!: number;\n  newObjectId!: number;\n  methodName!: string;\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  methodArguments!: any[];\n  source!: string;\n}\n\nexport class ItemsRange {\n  startPosition: number;\n  endPosition: number;\n  totalLength: number;\n  items: Array<Node|Edge>;\n  constructor(startPosition: number, endPosition: number, totalLength: number, items: Array<Node|Edge>) {\n    this.startPosition = startPosition;\n    this.endPosition = endPosition;\n    this.totalLength = totalLength;\n    this.items = items;\n  }\n}\n\nexport class StaticData {\n  nodeCount: number;\n  rootNodeIndex: number;\n  totalSize: number;\n  maxJSObjectId: number;\n  constructor(nodeCount: number, rootNodeIndex: number, totalSize: number, maxJSObjectId: number) {\n    this.nodeCount = nodeCount;\n    this.rootNodeIndex = rootNodeIndex;\n    this.totalSize = totalSize;\n    this.maxJSObjectId = maxJSObjectId;\n  }\n}\n\nexport interface Statistics {\n  total: number;\n  native: {total: number, typedArrays: number};\n  v8heap: {total: number, code: number, jsArrays: number, strings: number, system: number};\n}\n\nexport class NodeFilter {\n  minNodeId: number|undefined;\n  maxNodeId: number|undefined;\n  allocationNodeId!: number|undefined;\n  filterName: string|undefined;\n  constructor(minNodeId?: number, maxNodeId?: number) {\n    this.minNodeId = minNodeId;\n    this.maxNodeId = maxNodeId;\n  }\n\n  equals(o: NodeFilter): boolean {\n    return this.minNodeId === o.minNodeId && this.maxNodeId === o.maxNodeId &&\n        this.allocationNodeId === o.allocationNodeId && this.filterName === o.filterName;\n  }\n}\n\nexport class SearchConfig {\n  query: string;\n  caseSensitive: boolean;\n  isRegex: boolean;\n  shouldJump: boolean;\n  jumpBackward: boolean;\n  constructor(query: string, caseSensitive: boolean, isRegex: boolean, shouldJump: boolean, jumpBackward: boolean) {\n    this.query = query;\n    this.caseSensitive = caseSensitive;\n    this.isRegex = isRegex;\n    this.shouldJump = shouldJump;\n    this.jumpBackward = jumpBackward;\n  }\n\n  toSearchRegex(_global?: boolean): {regex: RegExp, fromQuery: boolean} {\n    throw new Error('Unsupported operation on search config');\n  }\n}\n\nexport class Samples {\n  timestamps: number[];\n  lastAssignedIds: number[];\n  sizes: number[];\n  constructor(timestamps: number[], lastAssignedIds: number[], sizes: number[]) {\n    this.timestamps = timestamps;\n    this.lastAssignedIds = lastAssignedIds;\n    this.sizes = sizes;\n  }\n}\n\nexport class Location {\n  scriptId: number;\n  lineNumber: number;\n  columnNumber: number;\n  constructor(scriptId: number, lineNumber: number, columnNumber: number) {\n    this.scriptId = scriptId;\n    this.lineNumber = lineNumber;\n    this.columnNumber = columnNumber;\n  }\n}\n","/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\n\nimport type {LiveObjects, Profile} from './HeapSnapshot.js';\n\nexport class AllocationProfile {\n  readonly #strings: string[];\n  #nextNodeId: number;\n  #functionInfos: FunctionAllocationInfo[];\n  #idToNode: Record<number, BottomUpAllocationNode|null>;\n  readonly #idToTopDownNode: Record<number, TopDownAllocationNode>;\n  #collapsedTopNodeIdToFunctionInfo: Record<number, FunctionAllocationInfo>;\n  #traceTops: HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[]|null;\n\n  constructor(profile: Profile, liveObjectStats: LiveObjects) {\n    this.#strings = profile.strings;\n\n    this.#nextNodeId = 1;\n    this.#functionInfos = [];\n\n    this.#idToNode = {};\n\n    this.#idToTopDownNode = {};\n\n    this.#collapsedTopNodeIdToFunctionInfo = {};\n\n    this.#traceTops = null;\n\n    this.#buildFunctionAllocationInfos(profile);\n    this.#buildAllocationTree(profile, liveObjectStats);\n  }\n\n  #buildFunctionAllocationInfos(profile: Profile): void {\n    const strings = this.#strings;\n\n    const functionInfoFields = profile.snapshot.meta.trace_function_info_fields;\n    const functionNameOffset = functionInfoFields.indexOf('name');\n    const scriptNameOffset = functionInfoFields.indexOf('script_name');\n    const scriptIdOffset = functionInfoFields.indexOf('script_id');\n    const lineOffset = functionInfoFields.indexOf('line');\n    const columnOffset = functionInfoFields.indexOf('column');\n    const functionInfoFieldCount = functionInfoFields.length;\n\n    const rawInfos = profile.trace_function_infos;\n    const infoLength = rawInfos.length;\n    const functionInfos = this.#functionInfos = new Array(infoLength / functionInfoFieldCount);\n    let index = 0;\n    for (let i = 0; i < infoLength; i += functionInfoFieldCount) {\n      functionInfos[index++] = new FunctionAllocationInfo(\n          strings[rawInfos[i + functionNameOffset]], strings[rawInfos[i + scriptNameOffset]],\n          rawInfos[i + scriptIdOffset], rawInfos[i + lineOffset], rawInfos[i + columnOffset]);\n    }\n  }\n\n  #buildAllocationTree(profile: Profile, liveObjectStats: LiveObjects): TopDownAllocationNode {\n    const traceTreeRaw = profile.trace_tree;\n    const functionInfos = this.#functionInfos;\n    const idToTopDownNode = this.#idToTopDownNode;\n\n    const traceNodeFields = profile.snapshot.meta.trace_node_fields;\n    const nodeIdOffset = traceNodeFields.indexOf('id');\n    const functionInfoIndexOffset = traceNodeFields.indexOf('function_info_index');\n    const allocationCountOffset = traceNodeFields.indexOf('count');\n    const allocationSizeOffset = traceNodeFields.indexOf('size');\n    const childrenOffset = traceNodeFields.indexOf('children');\n    const nodeFieldCount = traceNodeFields.length;\n\n    function traverseNode(\n        // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        rawNodeArray: any, nodeOffset: any, parent: TopDownAllocationNode|null): TopDownAllocationNode {\n      const functionInfo = functionInfos[rawNodeArray[nodeOffset + functionInfoIndexOffset]];\n      const id = rawNodeArray[nodeOffset + nodeIdOffset];\n      const stats = liveObjectStats[id];\n      const liveCount = stats ? stats.count : 0;\n      const liveSize = stats ? stats.size : 0;\n      const result = new TopDownAllocationNode(\n          id, functionInfo, rawNodeArray[nodeOffset + allocationCountOffset],\n          rawNodeArray[nodeOffset + allocationSizeOffset], liveCount, liveSize, parent);\n      idToTopDownNode[id] = result;\n      functionInfo.addTraceTopNode(result);\n\n      const rawChildren = rawNodeArray[nodeOffset + childrenOffset];\n      for (let i = 0; i < rawChildren.length; i += nodeFieldCount) {\n        result.children.push(traverseNode(rawChildren, i, result));\n      }\n\n      return result;\n    }\n\n    return traverseNode(traceTreeRaw, 0, null);\n  }\n\n  serializeTraceTops(): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[] {\n    if (this.#traceTops) {\n      return this.#traceTops;\n    }\n\n    const result: HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[] = this.#traceTops = [];\n    const functionInfos = this.#functionInfos;\n    for (let i = 0; i < functionInfos.length; i++) {\n      const info = functionInfos[i];\n      if (info.totalCount === 0) {\n        continue;\n      }\n      const nodeId = this.#nextNodeId++;\n      const isRoot = i === 0;\n      result.push(this.#serializeNode(\n          nodeId, info, info.totalCount, info.totalSize, info.totalLiveCount, info.totalLiveSize, !isRoot));\n      this.#collapsedTopNodeIdToFunctionInfo[nodeId] = info;\n    }\n    result.sort(function(a, b) {\n      return b.size - a.size;\n    });\n    return result;\n  }\n\n  serializeCallers(nodeId: number): HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers {\n    let node = this.#ensureBottomUpNode(nodeId);\n    const nodesWithSingleCaller = [];\n    while (node.callers().length === 1) {\n      node = node.callers()[0];\n      nodesWithSingleCaller.push(this.#serializeCaller(node));\n    }\n\n    const branchingCallers = [];\n    const callers = node.callers();\n    for (let i = 0; i < callers.length; i++) {\n      branchingCallers.push(this.#serializeCaller(callers[i]));\n    }\n\n    return new HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers(nodesWithSingleCaller, branchingCallers);\n  }\n\n  serializeAllocationStack(traceNodeId: number): HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame[] {\n    let node: (TopDownAllocationNode|null)|TopDownAllocationNode = this.#idToTopDownNode[traceNodeId];\n    const result = [];\n    while (node) {\n      const functionInfo = node.functionInfo;\n      result.push(new HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame(\n          functionInfo.functionName, functionInfo.scriptName, functionInfo.scriptId, functionInfo.line,\n          functionInfo.column));\n      node = node.parent;\n    }\n    return result;\n  }\n\n  traceIds(allocationNodeId: number): number[] {\n    return this.#ensureBottomUpNode(allocationNodeId).traceTopIds;\n  }\n\n  #ensureBottomUpNode(nodeId: number): BottomUpAllocationNode {\n    let node = this.#idToNode[nodeId];\n    if (!node) {\n      const functionInfo = this.#collapsedTopNodeIdToFunctionInfo[nodeId];\n      node = functionInfo.bottomUpRoot();\n      delete this.#collapsedTopNodeIdToFunctionInfo[nodeId];\n      this.#idToNode[nodeId] = node;\n    }\n    return node as BottomUpAllocationNode;\n  }\n\n  #serializeCaller(node: BottomUpAllocationNode): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode {\n    const callerId = this.#nextNodeId++;\n    this.#idToNode[callerId] = node;\n    return this.#serializeNode(\n        callerId, node.functionInfo, node.allocationCount, node.allocationSize, node.liveCount, node.liveSize,\n        node.hasCallers());\n  }\n\n  #serializeNode(\n      nodeId: number, functionInfo: FunctionAllocationInfo, count: number, size: number, liveCount: number,\n      liveSize: number, hasChildren: boolean): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode {\n    return new HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode(\n        nodeId, functionInfo.functionName, functionInfo.scriptName, functionInfo.scriptId, functionInfo.line,\n        functionInfo.column, count, size, liveCount, liveSize, hasChildren);\n  }\n}\n\nexport class TopDownAllocationNode {\n  id: number;\n  functionInfo: FunctionAllocationInfo;\n  allocationCount: number;\n  allocationSize: number;\n  liveCount: number;\n  liveSize: number;\n  parent: TopDownAllocationNode|null;\n  children: TopDownAllocationNode[];\n  constructor(\n      id: number, functionInfo: FunctionAllocationInfo, count: number, size: number, liveCount: number,\n      liveSize: number, parent: TopDownAllocationNode|null) {\n    this.id = id;\n    this.functionInfo = functionInfo;\n    this.allocationCount = count;\n    this.allocationSize = size;\n    this.liveCount = liveCount;\n    this.liveSize = liveSize;\n    this.parent = parent;\n\n    this.children = [];\n  }\n}\n\nexport class BottomUpAllocationNode {\n  functionInfo: FunctionAllocationInfo;\n  allocationCount: number;\n  allocationSize: number;\n  liveCount: number;\n  liveSize: number;\n  traceTopIds: number[];\n  readonly #callersInternal: BottomUpAllocationNode[];\n  constructor(functionInfo: FunctionAllocationInfo) {\n    this.functionInfo = functionInfo;\n    this.allocationCount = 0;\n    this.allocationSize = 0;\n    this.liveCount = 0;\n    this.liveSize = 0;\n\n    this.traceTopIds = [];\n\n    this.#callersInternal = [];\n  }\n\n  addCaller(traceNode: TopDownAllocationNode): BottomUpAllocationNode {\n    const functionInfo = traceNode.functionInfo;\n    let result;\n    for (let i = 0; i < this.#callersInternal.length; i++) {\n      const caller = this.#callersInternal[i];\n      if (caller.functionInfo === functionInfo) {\n        result = caller;\n        break;\n      }\n    }\n    if (!result) {\n      result = new BottomUpAllocationNode(functionInfo);\n      this.#callersInternal.push(result);\n    }\n    return result;\n  }\n\n  callers(): BottomUpAllocationNode[] {\n    return this.#callersInternal;\n  }\n\n  hasCallers(): boolean {\n    return this.#callersInternal.length > 0;\n  }\n}\n\nexport class FunctionAllocationInfo {\n  functionName: string;\n  scriptName: string;\n  scriptId: number;\n  line: number;\n  column: number;\n  totalCount: number;\n  totalSize: number;\n  totalLiveCount: number;\n  totalLiveSize: number;\n  #traceTops: TopDownAllocationNode[];\n  #bottomUpTree?: BottomUpAllocationNode;\n  constructor(functionName: string, scriptName: string, scriptId: number, line: number, column: number) {\n    this.functionName = functionName;\n    this.scriptName = scriptName;\n    this.scriptId = scriptId;\n    this.line = line;\n    this.column = column;\n    this.totalCount = 0;\n    this.totalSize = 0;\n    this.totalLiveCount = 0;\n    this.totalLiveSize = 0;\n\n    this.#traceTops = [];\n  }\n\n  addTraceTopNode(node: TopDownAllocationNode): void {\n    if (node.allocationCount === 0) {\n      return;\n    }\n    this.#traceTops.push(node);\n    this.totalCount += node.allocationCount;\n    this.totalSize += node.allocationSize;\n    this.totalLiveCount += node.liveCount;\n    this.totalLiveSize += node.liveSize;\n  }\n\n  bottomUpRoot(): BottomUpAllocationNode|null {\n    if (!this.#traceTops.length) {\n      return null;\n    }\n    if (!this.#bottomUpTree) {\n      this.#buildAllocationTraceTree();\n    }\n    return this.#bottomUpTree as BottomUpAllocationNode;\n  }\n\n  #buildAllocationTraceTree(): void {\n    this.#bottomUpTree = new BottomUpAllocationNode(this);\n\n    for (let i = 0; i < this.#traceTops.length; i++) {\n      let node: (TopDownAllocationNode|null)|TopDownAllocationNode = this.#traceTops[i];\n      let bottomUpNode: BottomUpAllocationNode = this.#bottomUpTree;\n      const count = node.allocationCount;\n      const size = node.allocationSize;\n      const liveCount = node.liveCount;\n      const liveSize = node.liveSize;\n      const traceId = node.id;\n      while (true) {\n        bottomUpNode.allocationCount += count;\n        bottomUpNode.allocationSize += size;\n        bottomUpNode.liveCount += liveCount;\n        bottomUpNode.liveSize += liveSize;\n        bottomUpNode.traceTopIds.push(traceId);\n        node = node.parent;\n        if (node === null) {\n          break;\n        }\n\n        bottomUpNode = bottomUpNode.addCaller(node);\n      }\n    }\n  }\n}\n","// Copyright 2021 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nlet devToolsLocaleInstance: DevToolsLocale|null = null;\n\nexport interface DevToolsLocaleData {\n  settingLanguage: string;\n  navigatorLanguage: string;\n  lookupClosestDevToolsLocale: (locale: string) => string;\n}\n\nexport type DevToolsLocaleCreationOptions = {\n  create: true,\n  data: DevToolsLocaleData,\n}|{\n  create: false,\n};\n\n/**\n * Simple class that determines the DevTools locale based on:\n *   1) navigator.language, which matches the Chrome UI\n *   2) the value of the \"language\" Setting the user choses\n *   3) available locales in DevTools.\n *\n * The DevTools locale is only determined once during startup and\n * guaranteed to never change. Use this class when using\n * `Intl` APIs.\n */\nexport class DevToolsLocale {\n  readonly locale: string;\n  readonly lookupClosestDevToolsLocale: (locale: string) => string;\n\n  private constructor(data: DevToolsLocaleData) {\n    this.lookupClosestDevToolsLocale = data.lookupClosestDevToolsLocale;\n\n    // TODO(crbug.com/1163928): Use constant once setting actually exists.\n    if (data.settingLanguage === 'browserLanguage') {\n      this.locale = data.navigatorLanguage || 'en-US';\n    } else {\n      this.locale = data.settingLanguage;\n    }\n\n    this.locale = this.lookupClosestDevToolsLocale(this.locale);\n  }\n\n  static instance(opts: DevToolsLocaleCreationOptions = {create: false}): DevToolsLocale {\n    if (!devToolsLocaleInstance && !opts.create) {\n      throw new Error('No LanguageSelector instance exists yet.');\n    }\n\n    if (opts.create) {\n      devToolsLocaleInstance = new DevToolsLocale(opts.data);\n    }\n    return devToolsLocaleInstance as DevToolsLocale;\n  }\n\n  static removeInstance(): void {\n    devToolsLocaleInstance = null;\n  }\n\n  forceFallbackLocale(): void {\n    // Locale is 'readonly', this is the only case where we want to forcibly\n    // overwrite the locale.\n    (this.locale as unknown) = 'en-US';\n  }\n\n  /**\n   * Returns true iff DevTools supports the language of the passed locale.\n   * Note that it doesn't have to be a one-to-one match, e.g. if DevTools supports\n   * 'de', then passing 'de-AT' will return true.\n   */\n  languageIsSupportedByDevTools(localeString: string): boolean {\n    return localeLanguagesMatch(localeString, this.lookupClosestDevToolsLocale(localeString));\n  }\n}\n\n/**\n * Returns true iff the two locales have matching languages. This means the\n * passing 'de-AT' and 'de-DE' will return true, while 'de-DE' and 'en' will\n * return false.\n */\nexport function localeLanguagesMatch(localeString1: string, localeString2: string): boolean {\n  const locale1 = new Intl.Locale(localeString1);\n  const locale2 = new Intl.Locale(localeString2);\n  return locale1.language === locale2.language;\n}\n","// Copyright 2018 The Lighthouse Authors. All Rights Reserved.\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n\nimport type {LocalizedMessages, UIStrings} from './i18n-impl.js';\n\nimport * as IntlMessageFormat from '../intl-messageformat/intl-messageformat.js';\n\nconst EMPTY_VALUES_OBJECT = {};\n\n/**\n * This class is usually created at module instantiation time and\n * holds the filename, the UIStrings object and a reference to\n * all the localization data.\n *\n * Later, once needed, users can request a `LocalizedStringSet` that represents\n * all the translated strings, in a given locale for the specific file and\n * UIStrings object.\n *\n * Please note that this class is implemented with invariant in mind that the\n * DevTools locale never changes. Otherwise we would have to use a Map as\n * the cache. For performance reasons, we store the single possible map entry\n * as a property directly.\n *\n * The DevTools locale CANNOT be passed via the constructor. When instances\n * of `RegisteredFileStrings` are created, the DevTools locale has not yet\n * been determined.\n */\nexport class RegisteredFileStrings {\n  private localizedStringSet?: LocalizedStringSet;\n\n  constructor(private filename: string, private stringStructure: UIStrings, private localizedMessages: Map<Intl.UnicodeBCP47LocaleIdentifier, LocalizedMessages>) {\n  }\n\n  getLocalizedStringSetFor(locale: Intl.UnicodeBCP47LocaleIdentifier): LocalizedStringSet {\n    if (this.localizedStringSet) {\n      return this.localizedStringSet;\n    }\n\n    const localeData = this.localizedMessages.get(locale);\n    if (!localeData) {\n      throw new Error(`No locale data registered for '${locale}'`);\n    }\n\n    this.localizedStringSet = new LocalizedStringSet(this.filename, this.stringStructure, locale, localeData);\n    return this.localizedStringSet;\n  }\n}\n\nexport type Values = Record<string, string|number|boolean>;\n\n/**\n * A set of translated strings for a single file in a specific locale.\n *\n * The class is a wrapper around `IntlMessageFormat#format` plus a cache\n * to speed up consecutive lookups of the same message.\n */\nexport class LocalizedStringSet {\n  private readonly cachedSimpleStrings = new Map<string, string>();\n  private readonly cachedMessageFormatters = new Map<string, IntlMessageFormat.IntlMessageFormat>();\n\n  /** For pseudo locales, use 'de-DE' for number formatting */\n  private readonly localeForFormatter: Intl.UnicodeBCP47LocaleIdentifier;\n\n  constructor(private filename: string, private stringStructure: UIStrings, locale: Intl.UnicodeBCP47LocaleIdentifier, private localizedMessages: LocalizedMessages) {\n    this.localeForFormatter = (locale === 'en-XA' || locale === 'en-XL') ? 'de-DE' : locale;\n  }\n\n  getLocalizedString(message: string, values: Values = EMPTY_VALUES_OBJECT): string {\n    if (values === EMPTY_VALUES_OBJECT || Object.keys(values).length === 0) {\n      return this.getSimpleLocalizedString(message);\n    }\n    return this.getFormattedLocalizedString(message, values);\n  }\n\n  getMessageFormatterFor(message: string): IntlMessageFormat.IntlMessageFormat {\n    const keyname = Object.keys(this.stringStructure).find(key => this.stringStructure[key] === message);\n    if (!keyname) {\n      throw new Error(`Unable to locate '${message}' in UIStrings object`);\n    }\n    const i18nId = `${this.filename} | ${keyname}`;\n    const localeMessage = this.localizedMessages[i18nId];\n\n    // The requested string might not yet have been collected into en-US.json or\n    // been translated yet. Fall back to the original TypeScript UIStrings message.\n    const messageToTranslate = localeMessage ? localeMessage.message : message;\n    return new IntlMessageFormat.IntlMessageFormat(messageToTranslate, this.localeForFormatter, undefined, {ignoreTag: true});\n  }\n\n  private getSimpleLocalizedString(message: string): string {\n    const cachedSimpleString = this.cachedSimpleStrings.get(message);\n    if (cachedSimpleString) {\n      return cachedSimpleString;\n    }\n\n    const formatter = this.getMessageFormatterFor(message);\n    try {\n      const translatedString = formatter.format() as string;\n      this.cachedSimpleStrings.set(message, translatedString);\n      return translatedString;\n    } catch  {\n      // The message could have been updated and use different placeholders then\n      // the translation. This is a rare edge case so it's fine to create a temporary\n      // IntlMessageFormat and fall back to the UIStrings message.\n      const formatter = new IntlMessageFormat.IntlMessageFormat(message, this.localeForFormatter, undefined, {ignoreTag: true});\n      const translatedString = formatter.format() as string;\n      this.cachedSimpleStrings.set(message, translatedString);\n      return translatedString;\n    }\n  }\n\n  private getFormattedLocalizedString(message: string, values: Values): string {\n    let formatter = this.cachedMessageFormatters.get(message);\n    if (!formatter) {\n      formatter = this.getMessageFormatterFor(message);\n      this.cachedMessageFormatters.set(message, formatter);\n    }\n\n    try {\n      return formatter.format(values) as string;\n    } catch {\n      // The message could have been updated and use different placeholders then\n      // the translation. This is a rare edge case so it's fine to create a temporary\n      // IntlMessageFormat and fall back to the UIStrings message.\n      const formatter = new IntlMessageFormat.IntlMessageFormat(message, this.localeForFormatter, undefined, {ignoreTag: true});\n      return formatter.format(values) as string;\n    }\n  }\n}\n","// Copyright 2018 The Lighthouse Authors. All Rights Reserved.\n// Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0\n// Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n\nimport {RegisteredFileStrings} from './localized-string-set.js';\n\nexport type UIStrings = Record<string, string>;\nexport type LocalizedMessages = Record<string, {message: string}>;\n\n/**\n * Encapsulates the global state of the i18n runtime.\n */\nexport class I18n {\n  readonly supportedLocales: ReadonlySet<Intl.UnicodeBCP47LocaleIdentifier>;\n\n  private localeData = new Map<Intl.UnicodeBCP47LocaleIdentifier, LocalizedMessages>();\n  readonly defaultLocale;\n\n  constructor(\n    supportedLocales: readonly Intl.UnicodeBCP47LocaleIdentifier[], defaultLocale: Intl.UnicodeBCP47LocaleIdentifier) {\n    this.defaultLocale = defaultLocale;\n\n    this.supportedLocales = new Set(supportedLocales);\n  }\n\n  registerLocaleData(locale: Intl.UnicodeBCP47LocaleIdentifier, messages: LocalizedMessages): void {\n    this.localeData.set(locale, messages);\n  }\n\n  hasLocaleDataForTest(locale: Intl.UnicodeBCP47LocaleIdentifier): boolean {\n    return this.localeData.has(locale);\n  }\n\n  resetLocaleDataForTest(): void {\n    this.localeData.clear();\n  }\n\n  registerFileStrings(filename: string, stringStructure: UIStrings): RegisteredFileStrings {\n    return new RegisteredFileStrings(filename, stringStructure, this.localeData);\n  }\n\n  /**\n   * Look up the best available locale for the requested language through these fall backs:\n   * - exact match\n   * - progressively shorter prefixes (`de-CH-1996` -> `de-CH` -> `de`)\n   * - the default locale if no match is found\n   */\n  lookupClosestSupportedLocale(locale: Intl.UnicodeBCP47LocaleIdentifier): Intl.UnicodeBCP47LocaleIdentifier {\n    const canonicalLocale: string = Intl.getCanonicalLocales(locale)[0];\n\n    const localeParts = canonicalLocale.split('-');\n    while (localeParts.length) {\n      const candidate = localeParts.join('-');\n      if (this.supportedLocales.has(candidate)) {\n        return candidate;\n      }\n      localeParts.pop();\n    }\n    return this.defaultLocale;\n  }\n}\n","// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const removeElement = <T>(array: T[], element: T, firstOnly?: boolean): boolean => {\n  let index = array.indexOf(element);\n  if (index === -1) {\n    return false;\n  }\n  if (firstOnly) {\n    array.splice(index, 1);\n    return true;\n  }\n  for (let i = index + 1, n = array.length; i < n; ++i) {\n    if (array[i] !== element) {\n      array[index++] = array[i];\n    }\n  }\n  array.length = index;\n  return true;\n};\n\ntype NumberComparator = (a: number, b: number) => number;\n\nfunction swap(array: number[], i1: number, i2: number): void {\n  const temp = array[i1];\n  array[i1] = array[i2];\n  array[i2] = temp;\n}\n\nfunction partition(\n    array: number[], comparator: NumberComparator, left: number, right: number, pivotIndex: number): number {\n  const pivotValue = array[pivotIndex];\n  swap(array, right, pivotIndex);\n  let storeIndex = left;\n  for (let i = left; i < right; ++i) {\n    if (comparator(array[i], pivotValue) < 0) {\n      swap(array, storeIndex, i);\n      ++storeIndex;\n    }\n  }\n  swap(array, right, storeIndex);\n  return storeIndex;\n}\n\nfunction quickSortRange(\n    array: number[], comparator: NumberComparator, left: number, right: number, sortWindowLeft: number,\n    sortWindowRight: number): void {\n  if (right <= left) {\n    return;\n  }\n  const pivotIndex = Math.floor(Math.random() * (right - left)) + left;\n  const pivotNewIndex = partition(array, comparator, left, right, pivotIndex);\n  if (sortWindowLeft < pivotNewIndex) {\n    quickSortRange(array, comparator, left, pivotNewIndex - 1, sortWindowLeft, sortWindowRight);\n  }\n  if (pivotNewIndex < sortWindowRight) {\n    quickSortRange(array, comparator, pivotNewIndex + 1, right, sortWindowLeft, sortWindowRight);\n  }\n}\n\nexport function sortRange(\n    array: number[], comparator: NumberComparator, leftBound: number, rightBound: number, sortWindowLeft: number,\n    sortWindowRight: number): number[] {\n  if (leftBound === 0 && rightBound === (array.length - 1) && sortWindowLeft === 0 && sortWindowRight >= rightBound) {\n    array.sort(comparator);\n  } else {\n    quickSortRange(array, comparator, leftBound, rightBound, sortWindowLeft, sortWindowRight);\n  }\n  return array;\n}\nexport const binaryIndexOf = <T, S>(array: T[], value: S, comparator: (a: S, b: T) => number): number => {\n  const index = lowerBound(array, value, comparator);\n  return index < array.length && comparator(value, array[index]) === 0 ? index : -1;\n};\n\nfunction mergeOrIntersect<T>(\n    array1: T[], array2: T[], comparator: (a: T, b: T) => number, mergeNotIntersect: boolean): T[] {\n  const result = [];\n  let i = 0;\n  let j = 0;\n  while (i < array1.length && j < array2.length) {\n    const compareValue = comparator(array1[i], array2[j]);\n    if (mergeNotIntersect || !compareValue) {\n      result.push(compareValue <= 0 ? array1[i] : array2[j]);\n    }\n    if (compareValue <= 0) {\n      i++;\n    }\n    if (compareValue >= 0) {\n      j++;\n    }\n  }\n  if (mergeNotIntersect) {\n    while (i < array1.length) {\n      result.push(array1[i++]);\n    }\n    while (j < array2.length) {\n      result.push(array2[j++]);\n    }\n  }\n  return result;\n}\n\nexport const intersectOrdered = <T>(array1: T[], array2: T[], comparator: (a: T, b: T) => number): T[] => {\n  return mergeOrIntersect(array1, array2, comparator, false);\n};\n\nexport const mergeOrdered = <T>(array1: T[], array2: T[], comparator: (a: T, b: T) => number): T[] => {\n  return mergeOrIntersect(array1, array2, comparator, true);\n};\n\nexport const DEFAULT_COMPARATOR = (a: string|number, b: string|number): -1|0|1 => {\n  return a < b ? -1 : (a > b ? 1 : 0);\n};\n\n/**\n * Returns the index of the element closest to the needle that is equal to or\n * greater than it. Assumes that the provided array is sorted.\n *\n * If no element is found, the right bound is returned.\n *\n * Uses the provided comparator function to determine if two items are equal or\n * if one is greater than the other. If you are working with strings or\n * numbers, you can use ArrayUtilities.DEFAULT_COMPARATOR. Otherwise, you\n * should define one that takes the needle element and an element from the\n * array and returns a positive or negative number to indicate which is greater\n * than the other.\n *\n * When specified, |left| (inclusive) and |right| (exclusive) indices\n * define the search window.\n */\nexport function lowerBound<T>(\n    array: Uint32Array|Int32Array, needle: T, comparator: (needle: T, b: number) => number, left?: number,\n    right?: number): number;\nexport function lowerBound<S, T>(\n    array: S[], needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number;\nexport function lowerBound<S, T>(\n    array: readonly S[], needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number;\nexport function lowerBound<S, T, A extends S[]>(\n    array: A, needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number {\n  let l = left || 0;\n  let r = right !== undefined ? right : array.length;\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (comparator(needle, array[m]) > 0) {\n      l = m + 1;\n    } else {\n      r = m;\n    }\n  }\n  return r;\n}\n\n/**\n * Returns the index of the element closest to the needle that is greater than\n * it. Assumes that the provided array is sorted.\n *\n * If no element is found, the right bound is returned.\n *\n * Uses the provided comparator function to determine if two items are equal or\n * if one is greater than the other. If you are working with strings or\n * numbers, you can use ArrayUtilities.DEFAULT_COMPARATOR. Otherwise, you\n * should define one that takes the needle element and an element from the\n * array and returns a positive or negative number to indicate which is greater\n * than the other.\n *\n * When specified, |left| (inclusive) and |right| (exclusive) indices\n * define the search window.\n */\nexport function upperBound<T>(\n    array: Uint32Array, needle: T, comparator: (needle: T, b: number) => number, left?: number, right?: number): number;\nexport function upperBound<S, T>(\n    array: S[], needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number;\nexport function upperBound<S, T, A extends S[]>(\n    array: A, needle: T, comparator: (needle: T, b: S) => number, left?: number, right?: number): number {\n  let l = left || 0;\n  let r = right !== undefined ? right : array.length;\n  while (l < r) {\n    const m = (l + r) >> 1;\n    if (comparator(needle, array[m]) >= 0) {\n      l = m + 1;\n    } else {\n      r = m;\n    }\n  }\n  return r;\n}\n\nconst enum NearestSearchStart {\n  BEGINNING = 'BEGINNING',\n  END = 'END',\n}\n/**\n * Obtains the first or last item in the array that satisfies the predicate function.\n * So, for example, if the array were arr = [2, 4, 6, 8, 10], and you are looking for\n * the last item arr[i] such that arr[i] < 5  you would be returned 1, because\n * array[1] is 4, the last item in the array that satisfies the\n * predicate function.\n *\n * If instead you were looking for the first item in the same array that satisfies\n * arr[i] > 5 you would be returned 2 because array[2] = 6.\n *\n * Please note: this presupposes that the array is already ordered.\n * This function uses a variation of Binary Search.\n */\nfunction nearestIndex<T>(\n    arr: readonly T[], predicate: (arrayItem: T) => boolean, searchStart: NearestSearchStart): number|null {\n  const searchFromEnd = searchStart === NearestSearchStart.END;\n  if (arr.length === 0) {\n    return null;\n  }\n\n  let left = 0;\n  let right = arr.length - 1;\n  let pivot = 0;\n  let matchesPredicate = false;\n  let moveToTheRight = false;\n  let middle = 0;\n  do {\n    middle = left + (right - left) / 2;\n    pivot = searchFromEnd ? Math.ceil(middle) : Math.floor(middle);\n    matchesPredicate = predicate(arr[pivot]);\n    moveToTheRight = matchesPredicate === searchFromEnd;\n    if (moveToTheRight) {\n      left = Math.min(right, pivot + (left === pivot ? 1 : 0));\n    } else {\n      right = Math.max(left, pivot + (right === pivot ? -1 : 0));\n    }\n  } while (right !== left);\n\n  // Special-case: the indexed item doesn't pass the predicate. This\n  // occurs when none of the items in the array are a match for the\n  // predicate.\n  if (!predicate(arr[left])) {\n    return null;\n  }\n  return left;\n}\n\n/**\n * Obtains the first item in the array that satisfies the predicate function.\n * So, for example, if the array was arr = [2, 4, 6, 8, 10], and you are looking for\n * the first item arr[i] such that arr[i] > 5 you would be returned 2, because\n * array[2] is 6, the first item in the array that satisfies the\n * predicate function.\n *\n * Please note: this presupposes that the array is already ordered.\n */\nexport function nearestIndexFromBeginning<T>(arr: T[], predicate: (arrayItem: T) => boolean): number|null {\n  return nearestIndex(arr, predicate, NearestSearchStart.BEGINNING);\n}\n\n/**\n * Obtains the last item in the array that satisfies the predicate function.\n * So, for example, if the array was arr = [2, 4, 6, 8, 10], and you are looking for\n * the last item arr[i] such that arr[i] < 5 you would be returned 1, because\n * arr[1] is 4, the last item in the array that satisfies the\n * predicate function.\n *\n * Please note: this presupposes that the array is already ordered.\n */\n\nexport function nearestIndexFromEnd<T>(arr: readonly T[], predicate: (arrayItem: T) => boolean): number|null {\n  return nearestIndex(arr, predicate, NearestSearchStart.END);\n}\n\n// Type guard for ensuring that `arr` does not contain null or undefined\nexport function arrayDoesNotContainNullOrUndefined<T>(arr: Array<T|null|undefined>): arr is T[] {\n  return !arr.includes(null) && !arr.includes(undefined);\n}\n","// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const inverse = function<K, V>(map: Map<K, V>): Multimap<V, K> {\n  const result = new Multimap<V, K>();\n  for (const [key, value] of map.entries()) {\n    result.set(value, key);\n  }\n  return result;\n};\n\nexport class Multimap<K, V> {\n  private map = new Map<K, Set<V>>();\n\n  set(key: K, value: V): void {\n    let set = this.map.get(key);\n    if (!set) {\n      set = new Set();\n      this.map.set(key, set);\n    }\n    set.add(value);\n  }\n\n  get(key: K): Set<V> {\n    return this.map.get(key) || new Set();\n  }\n\n  has(key: K): boolean {\n    return this.map.has(key);\n  }\n\n  hasValue(key: K, value: V): boolean {\n    const set = this.map.get(key);\n    if (!set) {\n      return false;\n    }\n    return set.has(value);\n  }\n\n  get size(): number {\n    return this.map.size;\n  }\n\n  delete(key: K, value: V): boolean {\n    const values = this.get(key);\n    if (!values) {\n      return false;\n    }\n    const result = values.delete(value);\n    if (!values.size) {\n      this.map.delete(key);\n    }\n    return result;\n  }\n\n  deleteAll(key: K): void {\n    this.map.delete(key);\n  }\n\n  keysArray(): K[] {\n    return [...this.map.keys()];\n  }\n\n  keys(): IterableIterator<K> {\n    return this.map.keys();\n  }\n\n  valuesArray(): V[] {\n    const result = [];\n    for (const set of this.map.values()) {\n      result.push(...set.values());\n    }\n    return result;\n  }\n\n  clear(): void {\n    this.map.clear();\n  }\n}\n\n/**\n * Gets value for key, assigning a default if value is falsy.\n */\n// eslint-disable-next-line @typescript-eslint/no-empty-object-type\nexport function getWithDefault<K extends {}, V>(\n    map: WeakMap<K, V>|Map<K, V>, key: K, defaultValueFactory: (key?: K) => V): V {\n  let value = map.get(key);\n  if (value === undefined || value === null) {\n    value = defaultValueFactory(key);\n    map.set(key, value);\n  }\n\n  return value;\n}\n","// Copyright (c) 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport type {Brand} from './Brand.js';\n\nexport const escapeCharacters = (inputString: string, charsToEscape: string): string => {\n  let foundChar = false;\n  for (let i = 0; i < charsToEscape.length; ++i) {\n    if (inputString.indexOf(charsToEscape.charAt(i)) !== -1) {\n      foundChar = true;\n      break;\n    }\n  }\n\n  if (!foundChar) {\n    return String(inputString);\n  }\n\n  let result = '';\n  for (let i = 0; i < inputString.length; ++i) {\n    if (charsToEscape.indexOf(inputString.charAt(i)) !== -1) {\n      result += '\\\\';\n    }\n    result += inputString.charAt(i);\n  }\n\n  return result;\n};\n\nconst toHexadecimal = (charCode: number, padToLength: number): string => {\n  return charCode.toString(16).toUpperCase().padStart(padToLength, '0');\n};\n\n// Remember to update the third group in the regexps patternsToEscape and\n// patternsToEscapePlusSingleQuote when adding new entries in this map.\nconst escapedReplacements = new Map([\n  ['\\b', '\\\\b'],\n  ['\\f', '\\\\f'],\n  ['\\n', '\\\\n'],\n  ['\\r', '\\\\r'],\n  ['\\t', '\\\\t'],\n  ['\\v', '\\\\v'],\n  ['\\'', '\\\\\\''],\n  ['\\\\', '\\\\\\\\'],\n  ['<!--', '\\\\x3C!--'],\n  ['<script', '\\\\x3Cscript'],\n  ['</script', '\\\\x3C/script'],\n]);\n\nexport const formatAsJSLiteral = (content: string): string => {\n  const patternsToEscape = /(\\\\|<(?:!--|\\/?script))|(\\p{Control})|(\\p{Surrogate})/gu;\n  const patternsToEscapePlusSingleQuote = /(\\\\|'|<(?:!--|\\/?script))|(\\p{Control})|(\\p{Surrogate})/gu;\n  const escapePattern = (match: string, pattern: string, controlChar: string, loneSurrogate: string): string => {\n    if (controlChar) {\n      if (escapedReplacements.has(controlChar)) {\n        // @ts-expect-error https://github.com/microsoft/TypeScript/issues/13086\n        return escapedReplacements.get(controlChar);\n      }\n      const twoDigitHex = toHexadecimal(controlChar.charCodeAt(0), 2);\n      return '\\\\x' + twoDigitHex;\n    }\n    if (loneSurrogate) {\n      const fourDigitHex = toHexadecimal(loneSurrogate.charCodeAt(0), 4);\n      return '\\\\u' + fourDigitHex;\n    }\n    if (pattern) {\n      return escapedReplacements.get(pattern) || '';\n    }\n    return match;\n  };\n\n  let escapedContent = '';\n  let quote = '';\n  if (!content.includes('\\'')) {\n    quote = '\\'';\n    escapedContent = content.replaceAll(patternsToEscape, escapePattern);\n  } else if (!content.includes('\"')) {\n    quote = '\"';\n    escapedContent = content.replaceAll(patternsToEscape, escapePattern);\n  } else if (!content.includes('`') && !content.includes('${')) {\n    quote = '`';\n    escapedContent = content.replaceAll(patternsToEscape, escapePattern);\n  } else {\n    quote = '\\'';\n    escapedContent = content.replaceAll(patternsToEscapePlusSingleQuote, escapePattern);\n  }\n  return `${quote}${escapedContent}${quote}`;\n};\n\n/**\n * This implements a subset of the sprintf() function described in the Single UNIX\n * Specification. It supports the %s, %f, %d, and %% formatting specifiers, and\n * understands the %m$d notation to select the m-th parameter for this substitution,\n * as well as the optional precision for %s, %f, and %d.\n *\n * @param fmt format string.\n * @param args parameters to the format string.\n * @returns the formatted output string.\n */\nexport const sprintf = (fmt: string, ...args: unknown[]): string => {\n  let argIndex = 0;\n  const RE = /%(?:(\\d+)\\$)?(?:\\.(\\d*))?([%dfs])/g;\n  return fmt.replaceAll(RE, (_: string, index?: string, precision?: string, specifier?: string) => {\n    if (specifier === '%') {\n      return '%';\n    }\n    if (index !== undefined) {\n      argIndex = parseInt(index, 10) - 1;\n      if (argIndex < 0) {\n        throw new RangeError(`Invalid parameter index ${argIndex + 1}`);\n      }\n    }\n    if (argIndex >= args.length) {\n      throw new RangeError(`Expected at least ${argIndex + 1} format parameters, but only ${args.length} where given.`);\n    }\n    if (specifier === 's') {\n      const argValue = String(args[argIndex++]);\n      if (precision !== undefined) {\n        return argValue.substring(0, Number(precision));\n      }\n      return argValue;\n    }\n    let argValue = Number(args[argIndex++]);\n    if (isNaN(argValue)) {\n      argValue = 0;\n    }\n    if (specifier === 'd') {\n      return String(Math.floor(argValue)).padStart(Number(precision), '0');\n    }\n    if (precision !== undefined) {\n      return argValue.toFixed(Number(precision));\n    }\n    return String(argValue);\n  });\n};\n\nexport const toBase64 = (inputString: string): string => {\n  /* note to the reader: we can't use btoa here because we need to\n   * support Unicode correctly. See the test cases for this function and\n   * also\n   * https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding#The_Unicode_Problem\n   */\n\n  function encodeBits(b: number): number {\n    return b < 26 ? b + 65 : b < 52 ? b + 71 : b < 62 ? b - 4 : b === 62 ? 43 : b === 63 ? 47 : 65;\n  }\n  const encoder = new TextEncoder();\n  const data = encoder.encode(inputString.toString());\n  const n = data.length;\n  let encoded = '';\n  if (n === 0) {\n    return encoded;\n  }\n  let shift;\n  let v = 0;\n  for (let i = 0; i < n; i++) {\n    shift = i % 3;\n    v |= data[i] << (16 >>> shift & 24);\n    if (shift === 2) {\n      encoded += String.fromCharCode(\n          encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), encodeBits(v >>> 6 & 63), encodeBits(v & 63));\n      v = 0;\n    }\n  }\n  if (shift === 0) {\n    encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), 61, 61);\n  } else if (shift === 1) {\n    encoded += String.fromCharCode(encodeBits(v >>> 18 & 63), encodeBits(v >>> 12 & 63), encodeBits(v >>> 6 & 63), 61);\n  }\n  return encoded;\n};\n\nexport const findIndexesOfSubString = (inputString: string, searchString: string): number[] => {\n  const matches = [];\n  let i = inputString.indexOf(searchString);\n  while (i !== -1) {\n    matches.push(i);\n    i = inputString.indexOf(searchString, i + searchString.length);\n  }\n  return matches;\n};\n\nexport const findLineEndingIndexes = (inputString: string): number[] => {\n  const endings = findIndexesOfSubString(inputString, '\\n');\n  endings.push(inputString.length);\n  return endings;\n};\n\nexport const isWhitespace = (inputString: string): boolean => {\n  return /^\\s*$/.test(inputString);\n};\n\nexport const trimURL = (url: string, baseURLDomain?: string): string => {\n  let result = url.replace(/^(https|http|file):\\/\\//i, '');\n  if (baseURLDomain) {\n    if (result.toLowerCase().startsWith(baseURLDomain.toLowerCase())) {\n      result = result.substr(baseURLDomain.length);\n    }\n  }\n  return result;\n};\n\nexport const collapseWhitespace = (inputString: string): string => {\n  return inputString.replace(/[\\s\\xA0]+/g, ' ');\n};\n\nexport const reverse = (inputString: string): string => {\n  return inputString.split('').reverse().join('');\n};\n\nexport const replaceControlCharacters = (inputString: string): string => {\n  // Replace C0 and C1 control character sets with replacement character.\n  // Do not replace '\\t', \\n' and '\\r'.\n  return inputString.replace(/[\\0-\\x08\\x0B\\f\\x0E-\\x1F\\x80-\\x9F]/g, '\\uFFFD');\n};\n\nexport const countWtf8Bytes = (inputString: string): number => {\n  let count = 0;\n  for (let i = 0; i < inputString.length; i++) {\n    const c = inputString.charCodeAt(i);\n    if (c <= 0x7F) {\n      count++;\n    } else if (c <= 0x07FF) {\n      count += 2;\n    } else if (c < 0xD800 || 0xDFFF < c) {\n      count += 3;\n    } else {\n      if (c <= 0xDBFF && i + 1 < inputString.length) {\n        // The current character is a leading surrogate, and there is a\n        // next character.\n        const next = inputString.charCodeAt(i + 1);\n        if (0xDC00 <= next && next <= 0xDFFF) {\n          // The next character is a trailing surrogate, meaning this\n          // is a surrogate pair.\n          count += 4;\n          i++;\n          continue;\n        }\n      }\n      count += 3;\n    }\n  }\n  return count;\n};\n\nexport const stripLineBreaks = (inputStr: string): string => {\n  return inputStr.replace(/(\\r)?\\n/g, '');\n};\n\nconst EXTENDED_KEBAB_CASE_REGEXP = /^([a-z0-9]+(?:-[a-z0-9]+)*\\.)*[a-z0-9]+(?:-[a-z0-9]+)*$/;\n\n/**\n * Tests if the `inputStr` is following the extended Kebab Case naming convetion,\n * where words are separated with either a dash (`-`) or a dot (`.`), and all\n * characters must be lower-case alphanumeric.\n *\n * For example, it will yield `true` for `'my.amazing-string.literal'`, but `false`\n * for `'Another.AmazingLiteral'` or '`another_amazing_literal'`.\n *\n * @param inputStr the input string to test.\n * @return `true` if the `inputStr` follows the extended Kebab Case convention.\n */\nexport const isExtendedKebabCase = (inputStr: string): boolean => {\n  return EXTENDED_KEBAB_CASE_REGEXP.test(inputStr);\n};\n\nexport const toTitleCase = (inputStr: string): string => {\n  return inputStr.substring(0, 1).toUpperCase() + inputStr.substring(1);\n};\n\nexport const removeURLFragment = (inputStr: string): string => {\n  const url = new URL(inputStr);\n  url.hash = '';\n  return url.toString();\n};\n\nconst SPECIAL_REGEX_CHARACTERS = '^[]{}()\\\\.^$*+?|-,';\n\nexport const regexSpecialCharacters = function(): string {\n  return SPECIAL_REGEX_CHARACTERS;\n};\n\nexport const filterRegex = function(query: string): RegExp {\n  let regexString = '^(?:.*\\\\0)?';  // Start from beginning or after a \\0\n  for (let i = 0; i < query.length; ++i) {\n    let c = query.charAt(i);\n    if (SPECIAL_REGEX_CHARACTERS.indexOf(c) !== -1) {\n      c = '\\\\' + c;\n    }\n    regexString += '[^\\\\0' + c + ']*' + c;\n  }\n  return new RegExp(regexString, 'i');\n};\n\nexport const createSearchRegex = function(\n    query: string, caseSensitive: boolean, isRegex: boolean, matchWholeWord = false): RegExp {\n  const regexFlags = caseSensitive ? 'g' : 'gi';\n  let regexObject;\n\n  if (isRegex) {\n    try {\n      regexObject = new RegExp(query, regexFlags);\n    } catch {\n      // Silent catch.\n    }\n  }\n\n  if (!regexObject) {\n    regexObject = createPlainTextSearchRegex(query, regexFlags);\n  }\n\n  if (matchWholeWord && regexObject) {\n    regexObject = new RegExp(`\\\\b${regexObject.source}\\\\b`, regexFlags);\n  }\n\n  return regexObject;\n};\n\nexport const caseInsensetiveComparator = function(a: string, b: string): number {\n  a = a.toUpperCase();\n  b = b.toUpperCase();\n  if (a === b) {\n    return 0;\n  }\n  return a > b ? 1 : -1;\n};\n\nexport const hashCode = function(string?: string): number {\n  if (!string) {\n    return 0;\n  }\n  // Hash algorithm for substrings is described in \"ber die Komplexitt der Multiplikation in\n  // eingeschrnkten Branchingprogrammmodellen\" by Woelfe.\n  // http://opendatastructures.org/versions/edition-0.1d/ods-java/node33.html#SECTION00832000000000000000\n  const p = ((1 << 30) * 4 - 5);  // prime: 2^32 - 5\n  const z = 0x5033d967;           // 32 bits from random.org\n  const z2 = 0x59d2f15d;          // random odd 32 bit number\n  let s = 0;\n  let zi = 1;\n  for (let i = 0; i < string.length; i++) {\n    const xi = string.charCodeAt(i) * z2;\n    s = (s + zi * xi) % p;\n    zi = (zi * z) % p;\n  }\n  s = (s + zi * (p - 1)) % p;\n  return Math.abs(s | 0);\n};\n\nexport const compare = (a: string, b: string): number => {\n  if (a > b) {\n    return 1;\n  }\n  if (a < b) {\n    return -1;\n  }\n  return 0;\n};\n\nexport const trimMiddle = (str: string, maxLength: number): string => {\n  if (str.length <= maxLength) {\n    return String(str);\n  }\n  let leftHalf = maxLength >> 1;\n  let rightHalf = maxLength - leftHalf - 1;\n  if ((str.codePointAt(str.length - rightHalf - 1) as number) >= 0x10000) {\n    --rightHalf;\n    ++leftHalf;\n  }\n  if (leftHalf > 0 && (str.codePointAt(leftHalf - 1) as number) >= 0x10000) {\n    --leftHalf;\n  }\n  return str.substr(0, leftHalf) + '' + str.substr(str.length - rightHalf, rightHalf);\n};\n\nexport const trimEndWithMaxLength = (str: string, maxLength: number): string => {\n  if (str.length <= maxLength) {\n    return String(str);\n  }\n  return str.substr(0, maxLength - 1) + '';\n};\n\nexport const escapeForRegExp = (str: string): string => {\n  return escapeCharacters(str, SPECIAL_REGEX_CHARACTERS);\n};\n\nexport const naturalOrderComparator = (a: string, b: string): number => {\n  const chunk = /^\\d+|^\\D+/;\n  let chunka, chunkb, anum, bnum;\n  while (true) {\n    if (a) {\n      if (!b) {\n        return 1;\n      }\n    } else {\n      if (b) {\n        return -1;\n      }\n      return 0;\n    }\n    chunka = (a.match(chunk) as string[])[0];\n    chunkb = (b.match(chunk) as string[])[0];\n    anum = !Number.isNaN(Number(chunka));\n    bnum = !Number.isNaN(Number(chunkb));\n    if (anum && !bnum) {\n      return -1;\n    }\n    if (bnum && !anum) {\n      return 1;\n    }\n    if (anum && bnum) {\n      const diff = Number(chunka) - Number(chunkb);\n      if (diff) {\n        return diff;\n      }\n      if (chunka.length !== chunkb.length) {\n        if (!Number(chunka) && !Number(chunkb)) {  // chunks are strings of all 0s (special case)\n          return chunka.length - chunkb.length;\n        }\n        return chunkb.length - chunka.length;\n      }\n    } else if (chunka !== chunkb) {\n      return (chunka < chunkb) ? -1 : 1;\n    }\n    a = a.substring(chunka.length);\n    b = b.substring(chunkb.length);\n  }\n};\n\nexport const base64ToSize = function(content: string|null): number {\n  if (!content) {\n    return 0;\n  }\n  let size = content.length * 3 / 4;\n  if (content[content.length - 1] === '=') {\n    size--;\n  }\n  if (content.length > 1 && content[content.length - 2] === '=') {\n    size--;\n  }\n  return size;\n};\n\nexport const SINGLE_QUOTE = '\\'';\nexport const DOUBLE_QUOTE = '\"';\nconst BACKSLASH = '\\\\';\n\nexport const findUnclosedCssQuote = function(str: string): string {\n  let unmatchedQuote = '';\n  for (let i = 0; i < str.length; ++i) {\n    const char = str[i];\n    if (char === BACKSLASH) {\n      i++;\n      continue;\n    }\n    if (char === SINGLE_QUOTE || char === DOUBLE_QUOTE) {\n      if (unmatchedQuote === char) {\n        unmatchedQuote = '';\n      } else if (unmatchedQuote === '') {\n        unmatchedQuote = char;\n      }\n    }\n  }\n  return unmatchedQuote;\n};\n\nexport const countUnmatchedLeftParentheses = (str: string): number => {\n  const stringLiteralRegex = /'(?:\\\\.|[^'\\\\])*'|\"(?:\\\\.|[^\"\\\\])*\"/g;\n  // Remove all matched string literals from the original string.\n  const strWithoutStrings = str.replace(stringLiteralRegex, '');\n\n  let unmatchedCount = 0;\n  for (const c of strWithoutStrings) {\n    if (c === '(') {\n      unmatchedCount++;\n    } else if (c === ')' && unmatchedCount > 0) {\n      unmatchedCount--;\n    }\n  }\n  return unmatchedCount;\n};\n\nexport const createPlainTextSearchRegex = function(query: string, flags?: string): RegExp {\n  // This should be kept the same as the one in StringUtil.cpp.\n  let regex = '';\n  for (let i = 0; i < query.length; ++i) {\n    const c = query.charAt(i);\n    if (regexSpecialCharacters().indexOf(c) !== -1) {\n      regex += '\\\\';\n    }\n    regex += c;\n  }\n  return new RegExp(regex, flags || '');\n};\n\nexport type LowerCaseString = Brand<string, 'lowerCaseStringTag'>;\n\nexport const toLowerCaseString = function(input: string): LowerCaseString {\n  return input.toLowerCase() as LowerCaseString;\n};\n\nconst WORD = /[A-Z]{2,}(?=[A-Z0-9][a-z0-9]+|\\b|_)|[A-Za-z][0-9]+[a-z]?|[A-Z]?[a-z]+|[0-9][A-Za-z]+|[A-Z]|[0-9]+|[.]/g;\n//            <---1---><------------2-----------> <---------3--------> <-----4----> <------5-----> <-----6----> <7>\n// 1: two or more consecutive uppercase letters. This is useful for identifying acronyms\n// 2: lookahead assertion that matches a word boundary\n// 3: numeronym: single letter followed by number and another letter\n// 4: word starting with an optional uppercase letter\n// 5: single digit followed by word to handle '3D' or '2px' (this might be controverial)\n// 6: single uppercase letter or number\n// 7: a dot character. We extract it into a separate word and remove dashes around it later.\n//    This is makes more sense conceptually and allows accounting for all possible word variants.\n//    Making dot a part of a word prevent us from handling acronyms or numeronyms after the word\n//    correctly without making the RegExp prohibitively complicated.\n// https://regex101.com/r/FhMVKc/1\nexport const toKebabCase = function(input: string): Lowercase<string> {\n  return (input.match?.(WORD)?.map(w => w.toLowerCase()).join('-').replaceAll('-.-', '.') || input) as\n      Lowercase<string>;\n};\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport function toKebabCaseKeys(settingValue: Record<string, any>): Record<string, any> {\n  const result: Record<string, any> = {};\n  for (const [key, value] of Object.entries(settingValue)) {\n    result[toKebabCase(key)] = value;\n  }\n  return result;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n// Replaces the last ocurrence of parameter `search` with parameter `replacement` in `input`\nexport const replaceLast = function(input: string, search: string, replacement: string): string {\n  const replacementStartIndex = input.lastIndexOf(search);\n  if (replacementStartIndex === -1) {\n    return input;\n  }\n\n  return input.slice(0, replacementStartIndex) + input.slice(replacementStartIndex).replace(search, replacement);\n};\n\nexport const stringifyWithPrecision = function stringifyWithPrecision(s: number, precision = 2): string {\n  if (precision === 0) {\n    return s.toFixed(0);\n  }\n  const string = s.toFixed(precision).replace(/\\.?0*$/, '');\n  return string === '-0' ? '0' : string;\n};\n\n/**\n * Somewhat efficiently concatenates 2 base64 encoded strings.\n */\nexport const concatBase64 = function(lhs: string, rhs: string): string {\n  if (lhs.length === 0 || !lhs.endsWith('=')) {\n    // Empty string or no padding, we can straight-up concatenate.\n    return lhs + rhs;\n  }\n  const lhsLeaveAsIs = lhs.substring(0, lhs.length - 4);\n  const lhsToDecode = lhs.substring(lhs.length - 4);\n  return lhsLeaveAsIs + window.btoa(window.atob(lhsToDecode) + window.atob(rhs));\n};\n","// Copyright 2024 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\n/**\n * An object which provides functionality similar to Uint32Array. It may be\n * implemented as:\n * 1. A Uint32Array,\n * 2. An array of Uint32Arrays, to support more data than Uint32Array, or\n * 3. A plain array, in which case the length may change by setting values.\n */\nexport interface BigUint32Array {\n  get length(): number;\n  getValue(index: number): number;\n  setValue(index: number, value: number): void;\n  asUint32ArrayOrFail(): Uint32Array;\n  asArrayOrFail(): number[];\n}\n\n/**\n * @returns A BigUint32Array implementation which is based on Array.\n * This means that its length automatically expands to include the highest index\n * used, and asArrayOrFail will succeed.\n */\nexport function createExpandableBigUint32Array(): BigUint32Array {\n  return new ExpandableBigUint32ArrayImpl();\n}\n\n/**\n * @returns A BigUint32Array implementation which is based on Uint32Array.\n * If the length is small enough to fit in a single Uint32Array, then\n * asUint32ArrayOrFail will succeed. Otherwise, it will throw an exception.\n */\nexport function createFixedBigUint32Array(length: number, maxLengthForTesting?: number): BigUint32Array {\n  try {\n    if (maxLengthForTesting !== undefined && length > maxLengthForTesting) {\n      // Simulate allocation failure.\n      throw new RangeError();\n    }\n    return new BasicBigUint32ArrayImpl(length);\n  } catch {\n    // We couldn't allocate a big enough ArrayBuffer.\n    return new SplitBigUint32ArrayImpl(length, maxLengthForTesting);\n  }\n}\n\nclass BasicBigUint32ArrayImpl extends Uint32Array implements BigUint32Array {\n  getValue(index: number): number {\n    return this[index];\n  }\n  setValue(index: number, value: number): void {\n    this[index] = value;\n  }\n  asUint32ArrayOrFail(): Uint32Array {\n    return this;\n  }\n  asArrayOrFail(): number[] {\n    throw new Error('Not an array');\n  }\n}\n\nclass SplitBigUint32ArrayImpl implements BigUint32Array {\n  #data: Uint32Array[];\n  #partLength: number;\n  length: number;\n\n  constructor(length: number, maxLengthForTesting?: number) {\n    this.#data = [];\n    this.length = length;\n    let partCount = 1;\n    while (true) {\n      partCount *= 2;\n      this.#partLength = Math.ceil(length / partCount);\n      try {\n        if (maxLengthForTesting !== undefined && this.#partLength > maxLengthForTesting) {\n          // Simulate allocation failure.\n          throw new RangeError();\n        }\n        for (let i = 0; i < partCount; ++i) {\n          this.#data[i] = new Uint32Array(this.#partLength);\n        }\n        return;\n      } catch (e) {\n        if (this.#partLength < 1e6) {\n          // The length per part is already small, so continuing to subdivide it\n          // will probably not help.\n          throw e;\n        }\n      }\n    }\n  }\n\n  getValue(index: number): number {\n    if (index >= 0 && index < this.length) {\n      const partLength = this.#partLength;\n      return this.#data[Math.floor(index / partLength)][index % partLength];\n    }\n    // On out-of-bounds accesses, match the behavior of Uint32Array: return an\n    // undefined value that's incorrectly typed as number.\n    return this.#data[0][-1];\n  }\n\n  setValue(index: number, value: number): void {\n    if (index >= 0 && index < this.length) {\n      const partLength = this.#partLength;\n      this.#data[Math.floor(index / partLength)][index % partLength] = value;\n    }\n    // Attempting to set a value out of bounds does nothing, like Uint32Array.\n  }\n\n  asUint32ArrayOrFail(): Uint32Array {\n    throw new Error('Not a Uint32Array');\n  }\n  asArrayOrFail(): number[] {\n    throw new Error('Not an array');\n  }\n}\n\nclass ExpandableBigUint32ArrayImpl extends Array<number> implements BigUint32Array {\n  getValue(index: number): number {\n    return this[index];\n  }\n  setValue(index: number, value: number): void {\n    this[index] = value;\n  }\n  asUint32ArrayOrFail(): Uint32Array {\n    throw new Error('Not a Uint32Array');\n  }\n  asArrayOrFail(): number[] {\n    return this;\n  }\n}\n\nexport interface BitVector {\n  getBit(index: number): boolean;\n  setBit(index: number): void;\n  clearBit(index: number): void;\n  // Returns the last bit before `index` which is set, or -1 if there are none.\n  previous(index: number): number;\n  get buffer(): ArrayBuffer;\n}\n\nexport function createBitVector(lengthOrBuffer: number|ArrayBuffer): BitVector {\n  return new BitVectorImpl(lengthOrBuffer);\n}\n\nclass BitVectorImpl extends Uint8Array {\n  constructor(lengthOrBuffer: number|ArrayBuffer) {\n    if (typeof lengthOrBuffer === 'number') {\n      super(Math.ceil(lengthOrBuffer / 8));\n    } else {\n      super(lengthOrBuffer);\n    }\n  }\n  getBit(index: number): boolean {\n    const value = this[index >> 3] & (1 << (index & 7));\n    return value !== 0;\n  }\n  setBit(index: number): void {\n    this[index >> 3] |= (1 << (index & 7));\n  }\n  clearBit(index: number): void {\n    this[index >> 3] &= ~(1 << (index & 7));\n  }\n  previous(index: number): number {\n    // First, check for more bits in the current byte.\n    while (index !== ((index >> 3) << 3)) {\n      --index;\n      if (this.getBit(index)) {\n        return index;\n      }\n    }\n    // Next, iterate by bytes to skip over ranges of zeros.\n    let byteIndex: number = (index >> 3) - 1;\n    while (byteIndex >= 0 && this[byteIndex] === 0) {\n      --byteIndex;\n    }\n    if (byteIndex < 0) {\n      return -1;\n    }\n    // Finally, iterate the nonzero byte to find the highest bit.\n    for (index = (byteIndex << 3) + 7; index >= (byteIndex << 3); --index) {\n      if (this.getBit(index)) {\n        return index;\n      }\n    }\n    throw new Error('Unreachable');\n  }\n}\n","// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as Platform from '../platform/platform.js';\n\nconst queryParamsObject = new URLSearchParams(location.search);\n\nlet runtimePlatform = '';\n\nlet runtimeInstance: Runtime|undefined;\nlet isNode: boolean|undefined;\n\n/** Returns the base URL (similar to `<base>`).\n * Used to resolve the relative URLs of any additional DevTools files (locale strings, etc) needed.\n * See: https://cs.chromium.org/remoteBase+f:devtools_window\n */\nexport function getRemoteBase(location: string = self.location.toString()): {\n  base: string,\n  version: string,\n}|null {\n  const url = new URL(location);\n  const remoteBase = url.searchParams.get('remoteBase');\n  if (!remoteBase) {\n    return null;\n  }\n\n  const version = /\\/serve_file\\/(@[0-9a-zA-Z]+)\\/?$/.exec(remoteBase);\n  if (!version) {\n    return null;\n  }\n\n  return {base: `devtools://devtools/remote/serve_file/${version[1]}/`, version: version[1]};\n}\n\nexport function getPathName(): string {\n  return window.location.pathname;\n}\n\nexport function isNodeEntry(pathname: string): boolean {\n  const nodeEntryPoints = ['node_app', 'js_app'];\n  return nodeEntryPoints.some(component => pathname.includes(component));\n}\n\nexport const getChromeVersion = (): string => {\n  const chromeRegex = /(?:^|\\W)(?:Chrome|HeadlessChrome)\\/(\\S+)/;\n  const chromeMatch = navigator.userAgent.match(chromeRegex);\n  if (chromeMatch && chromeMatch.length > 1) {\n    return chromeMatch[1];\n  }\n  return '';\n};\n\nexport class Runtime {\n  private constructor() {\n  }\n\n  static instance(opts: {\n    forceNew: boolean|null,\n  }|undefined = {forceNew: null}): Runtime {\n    const {forceNew} = opts;\n    if (!runtimeInstance || forceNew) {\n      runtimeInstance = new Runtime();\n    }\n\n    return runtimeInstance;\n  }\n\n  static removeInstance(): void {\n    runtimeInstance = undefined;\n  }\n\n  static queryParam(name: string): string|null {\n    return queryParamsObject.get(name);\n  }\n\n  static setQueryParamForTesting(name: string, value: string): void {\n    queryParamsObject.set(name, value);\n  }\n\n  static isNode(): boolean {\n    if (isNode === undefined) {\n      isNode = isNodeEntry(getPathName());\n    }\n    return isNode;\n  }\n\n  static setPlatform(platform: string): void {\n    runtimePlatform = platform;\n  }\n\n  static platform(): string {\n    return runtimePlatform;\n  }\n\n  static isDescriptorEnabled(descriptor: {experiment?: string|null, condition?: Condition}): boolean {\n    const {experiment} = descriptor;\n    if (experiment === '*') {\n      return true;\n    }\n    if (experiment && experiment.startsWith('!') && experiments.isEnabled(experiment.substring(1))) {\n      return false;\n    }\n    if (experiment && !experiment.startsWith('!') && !experiments.isEnabled(experiment)) {\n      return false;\n    }\n    const {condition} = descriptor;\n    return condition ? condition(hostConfig) : true;\n  }\n\n  loadLegacyModule(modulePath: string): Promise<unknown> {\n    // eslint-disable-next-line no-console\n    console.log('Loading legacy module: ' + modulePath);\n    const importPath =\n        `../../${modulePath}`;  // Extracted as a variable so esbuild doesn't attempt to bundle all the things.\n    return import(importPath).then(m => {\n      // eslint-disable-next-line no-console\n      console.log('Loaded legacy module: ' + modulePath);\n      return m;\n    });\n  }\n}\n\nexport interface Option {\n  title: string;\n  value: string|boolean;\n  raw?: boolean;\n  text?: string;\n}\n\nexport class ExperimentsSupport {\n  #experiments: Experiment[] = [];\n  readonly #experimentNames = new Set<string>();\n  readonly #enabledTransiently = new Set<string>();\n  readonly #enabledByDefault = new Set<string>();\n  readonly #serverEnabled = new Set<string>();\n  readonly #storage = new ExperimentStorage();\n\n  allConfigurableExperiments(): Experiment[] {\n    const result = [];\n    for (const experiment of this.#experiments) {\n      if (!this.#enabledTransiently.has(experiment.name)) {\n        result.push(experiment);\n      }\n    }\n    return result;\n  }\n\n  register(\n      experimentName: string, experimentTitle: string, unstable?: boolean, docLink?: string,\n      feedbackLink?: string): void {\n    if (this.#experimentNames.has(experimentName)) {\n      throw new Error(`Duplicate registration of experiment '${experimentName}'`);\n    }\n    this.#experimentNames.add(experimentName);\n    this.#experiments.push(new Experiment(\n        this, experimentName, experimentTitle, Boolean(unstable),\n        docLink as Platform.DevToolsPath.UrlString ?? Platform.DevToolsPath.EmptyUrlString,\n        feedbackLink as Platform.DevToolsPath.UrlString ?? Platform.DevToolsPath.EmptyUrlString));\n  }\n\n  isEnabled(experimentName: string): boolean {\n    this.checkExperiment(experimentName);\n    // Check for explicitly disabled #experiments first - the code could call setEnable(false) on the experiment enabled\n    // by default and we should respect that.\n    if (this.#storage.get(experimentName) === false) {\n      return false;\n    }\n    if (this.#enabledTransiently.has(experimentName) || this.#enabledByDefault.has(experimentName)) {\n      return true;\n    }\n    if (this.#serverEnabled.has(experimentName)) {\n      return true;\n    }\n\n    return Boolean(this.#storage.get(experimentName));\n  }\n\n  setEnabled(experimentName: string, enabled: boolean): void {\n    this.checkExperiment(experimentName);\n    this.#storage.set(experimentName, enabled);\n  }\n\n  enableExperimentsTransiently(experimentNames: string[]): void {\n    for (const experimentName of experimentNames) {\n      this.checkExperiment(experimentName);\n      this.#enabledTransiently.add(experimentName);\n    }\n  }\n\n  enableExperimentsByDefault(experimentNames: string[]): void {\n    for (const experimentName of experimentNames) {\n      this.checkExperiment(experimentName);\n      this.#enabledByDefault.add(experimentName);\n    }\n  }\n\n  setServerEnabledExperiments(experimentNames: string[]): void {\n    for (const experiment of experimentNames) {\n      this.checkExperiment(experiment);\n      this.#serverEnabled.add(experiment);\n    }\n  }\n\n  enableForTest(experimentName: string): void {\n    this.checkExperiment(experimentName);\n    this.#enabledTransiently.add(experimentName);\n  }\n\n  disableForTest(experimentName: string): void {\n    this.checkExperiment(experimentName);\n    this.#enabledTransiently.delete(experimentName);\n  }\n\n  clearForTest(): void {\n    this.#experiments = [];\n    this.#experimentNames.clear();\n    this.#enabledTransiently.clear();\n    this.#enabledByDefault.clear();\n    this.#serverEnabled.clear();\n  }\n\n  cleanUpStaleExperiments(): void {\n    this.#storage.cleanUpStaleExperiments(this.#experimentNames);\n  }\n\n  private checkExperiment(experimentName: string): void {\n    if (!this.#experimentNames.has(experimentName)) {\n      throw new Error(`Unknown experiment '${experimentName}'`);\n    }\n  }\n}\n\n/** Manages the 'experiments' dictionary in self.localStorage */\nclass ExperimentStorage {\n  readonly #experiments: Record<string, boolean|undefined> = {};\n\n  constructor() {\n    try {\n      const storedExperiments = self.localStorage?.getItem('experiments');\n      if (storedExperiments) {\n        this.#experiments = JSON.parse(storedExperiments);\n      }\n    } catch {\n      console.error('Failed to parse localStorage[\\'experiments\\']');\n    }\n  }\n\n  /**\n   * Experiments are stored with a tri-state:\n   *   - true: Explicitly enabled.\n   *   - false: Explicitly disabled.\n   *   - undefined: Disabled.\n   */\n  get(experimentName: string): boolean|undefined {\n    return this.#experiments[experimentName];\n  }\n\n  set(experimentName: string, enabled: boolean): void {\n    this.#experiments[experimentName] = enabled;\n    this.#syncToLocalStorage();\n  }\n\n  cleanUpStaleExperiments(validExperiments: Set<string>): void {\n    for (const [key] of Object.entries(this.#experiments)) {\n      if (!validExperiments.has(key)) {\n        delete this.#experiments[key];\n      }\n    }\n    this.#syncToLocalStorage();\n  }\n\n  #syncToLocalStorage(): void {\n    self.localStorage?.setItem('experiments', JSON.stringify(this.#experiments));\n  }\n}\n\nexport class Experiment {\n  name: string;\n  title: string;\n  unstable: boolean;\n  docLink?: Platform.DevToolsPath.UrlString;\n  readonly feedbackLink?: Platform.DevToolsPath.UrlString;\n  readonly #experiments: ExperimentsSupport;\n  constructor(\n      experiments: ExperimentsSupport, name: string, title: string, unstable: boolean,\n      docLink: Platform.DevToolsPath.UrlString, feedbackLink: Platform.DevToolsPath.UrlString) {\n    this.name = name;\n    this.title = title;\n    this.unstable = unstable;\n    this.docLink = docLink;\n    this.feedbackLink = feedbackLink;\n    this.#experiments = experiments;\n  }\n\n  isEnabled(): boolean {\n    return this.#experiments.isEnabled(this.name);\n  }\n\n  setEnabled(enabled: boolean): void {\n    this.#experiments.setEnabled(this.name, enabled);\n  }\n}\n\n// This must be constructed after the query parameters have been parsed.\nexport const experiments = new ExperimentsSupport();\n\nexport const enum ExperimentName {\n  CAPTURE_NODE_CREATION_STACKS = 'capture-node-creation-stacks',\n  CSS_OVERVIEW = 'css-overview',\n  LIVE_HEAP_PROFILE = 'live-heap-profile',\n  ALL = '*',\n  PROTOCOL_MONITOR = 'protocol-monitor',\n  FULL_ACCESSIBILITY_TREE = 'full-accessibility-tree',\n  HEADER_OVERRIDES = 'header-overrides',\n  INSTRUMENTATION_BREAKPOINTS = 'instrumentation-breakpoints',\n  AUTHORED_DEPLOYED_GROUPING = 'authored-deployed-grouping',\n  JUST_MY_CODE = 'just-my-code',\n  HIGHLIGHT_ERRORS_ELEMENTS_PANEL = 'highlight-errors-elements-panel',\n  USE_SOURCE_MAP_SCOPES = 'use-source-map-scopes',\n  TIMELINE_SHOW_POST_MESSAGE_EVENTS = 'timeline-show-postmessage-events',\n  TIMELINE_DEBUG_MODE = 'timeline-debug-mode',\n  TIMELINE_ENHANCED_TRACES = 'timeline-enhanced-traces',\n  TIMELINE_COMPILED_SOURCES = 'timeline-compiled-sources',\n  TIMELINE_SAVE_AS_GZ = 'timeline-save-as-gz',\n  VERTICAL_DRAWER = 'vertical-drawer',\n  // Adding or removing an entry from this enum?\n  // You will need to update:\n  // 1. REGISTERED_EXPERIMENTS in EnvironmentHelpers.ts (to create this experiment in the test env)\n  // 2. DevToolsExperiments enum in host/UserMetrics.ts\n}\n\nexport enum GenAiEnterprisePolicyValue {\n  ALLOW = 0,\n  ALLOW_WITHOUT_LOGGING = 1,\n  DISABLE = 2,\n}\n\nexport interface AidaAvailability {\n  enabled: boolean;\n  blockedByAge: boolean;\n  blockedByEnterprisePolicy: boolean;\n  blockedByGeo: boolean;\n  disallowLogging: boolean;\n  enterprisePolicyValue: number;\n}\n\ntype Channel = 'stable'|'beta'|'dev'|'canary';\n\nexport interface HostConfigConsoleInsights {\n  modelId: string;\n  temperature: number;\n  enabled: boolean;\n}\n\nexport enum HostConfigFreestylerExecutionMode {\n  ALL_SCRIPTS = 'ALL_SCRIPTS',\n  SIDE_EFFECT_FREE_SCRIPTS_ONLY = 'SIDE_EFFECT_FREE_SCRIPTS_ONLY',\n  NO_SCRIPTS = 'NO_SCRIPTS',\n}\n\nexport interface HostConfigFreestyler {\n  modelId: string;\n  temperature: number;\n  enabled: boolean;\n  userTier: string;\n  executionMode?: HostConfigFreestylerExecutionMode;\n  patching?: boolean;\n  multimodal?: boolean;\n  multimodalUploadInput?: boolean;\n  functionCalling?: boolean;\n  featureName?: string;\n}\n\nexport interface HostConfigAiAssistanceNetworkAgent {\n  modelId: string;\n  temperature: number;\n  enabled: boolean;\n  userTier: string;\n  featureName?: string;\n}\n\nexport interface HostConfigAiAssistancePerformanceAgent {\n  modelId: string;\n  temperature: number;\n  enabled: boolean;\n  userTier: string;\n  // Introduced in crrev.com/c/6243415\n  insightsEnabled?: boolean;\n  featureName?: string;\n}\n\nexport interface HostConfigAiAssistanceFileAgent {\n  modelId: string;\n  temperature: number;\n  enabled: boolean;\n  userTier: string;\n  featureName?: string;\n}\n\nexport interface HostConfigAiCodeCompletion {\n  modelId: string;\n  temperature: number;\n  enabled: boolean;\n  userTier: string;\n}\n\nexport interface HostConfigDeepLinksViaExtensibilityApi {\n  enabled: boolean;\n}\n\nexport interface HostConfigVeLogging {\n  enabled: boolean;\n  testing: boolean;\n}\n\n/**\n * @see https://goo.gle/devtools-json-design\n */\nexport interface HostConfigWellKnown {\n  enabled: boolean;\n}\n\nexport interface HostConfigPrivacyUI {\n  enabled: boolean;\n}\n\nexport interface HostConfigEnableOriginBoundCookies {\n  portBindingEnabled: boolean;\n  schemeBindingEnabled: boolean;\n}\n\nexport interface HostConfigAnimationStylesInStylesTab {\n  enabled: boolean;\n}\n\nexport interface HostConfigThirdPartyCookieControls {\n  thirdPartyCookieRestrictionEnabled: boolean;\n  thirdPartyCookieMetadataEnabled: boolean;\n  thirdPartyCookieHeuristicsEnabled: boolean;\n  managedBlockThirdPartyCookies: string|boolean;\n}\n\ninterface AiGeneratedTimelineLabels {\n  enabled: boolean;\n}\n\ninterface AllowPopoverForcing {\n  enabled: boolean;\n}\n\ninterface AiSubmenuPrompts {\n  enabled: boolean;\n}\n\ninterface IpProtectionInDevTools {\n  enabled: boolean;\n}\n\n/**\n * The host configuration that we expect from the DevTools back-end.\n *\n * We use `RecursivePartial` here to enforce that DevTools code is able to\n * handle `HostConfig` objects of an unexpected shape. This can happen if\n * the implementation in the Chromium backend is changed without correctly\n * updating the DevTools frontend. Or if remote debugging a different version\n * of Chrome, resulting in the local browser window and the local DevTools\n * window being of different versions, and consequently potentially having\n * differently shaped `HostConfig`s.\n *\n * @see hostConfig\n */\nexport type HostConfig = Platform.TypeScriptUtilities.RecursivePartial<{\n  aidaAvailability: AidaAvailability,\n  channel: Channel,\n  devToolsConsoleInsights: HostConfigConsoleInsights,\n  devToolsDeepLinksViaExtensibilityApi: HostConfigDeepLinksViaExtensibilityApi,\n  devToolsFreestyler: HostConfigFreestyler,\n  devToolsAiAssistanceNetworkAgent: HostConfigAiAssistanceNetworkAgent,\n  devToolsAiAssistanceFileAgent: HostConfigAiAssistanceFileAgent,\n  devToolsAiAssistancePerformanceAgent: HostConfigAiAssistancePerformanceAgent,\n  devToolsAiCodeCompletion: HostConfigAiCodeCompletion,\n  devToolsVeLogging: HostConfigVeLogging,\n  devToolsWellKnown: HostConfigWellKnown,\n  devToolsPrivacyUI: HostConfigPrivacyUI,\n  /**\n   * OffTheRecord here indicates that the user's profile is either incognito,\n   * or guest mode, rather than a \"normal\" profile.\n   */\n  isOffTheRecord: boolean,\n  devToolsEnableOriginBoundCookies: HostConfigEnableOriginBoundCookies,\n  devToolsAnimationStylesInStylesTab: HostConfigAnimationStylesInStylesTab,\n  thirdPartyCookieControls: HostConfigThirdPartyCookieControls,\n  devToolsAiGeneratedTimelineLabels: AiGeneratedTimelineLabels,\n  devToolsAllowPopoverForcing: AllowPopoverForcing,\n  devToolsAiSubmenuPrompts: AiSubmenuPrompts,\n  devToolsIpProtectionInDevTools: IpProtectionInDevTools,\n}>;\n\n/**\n * The host configuration for this DevTools instance.\n *\n * This is initialized early during app startup and should not be modified\n * afterwards. In some cases it can be necessary to re-request the host\n * configuration from Chrome while DevTools is already running. In these\n * cases, the new host configuration should be reflected here, e.g.:\n *\n * ```js\n * const config = await new Promise<Root.Runtime.HostConfig>(\n *   resolve => InspectorFrontendHostInstance.getHostConfig(resolve));\n * Object.assign(Root.runtime.hostConfig, config);\n * ```\n */\nexport const hostConfig: Platform.TypeScriptUtilities.RecursiveReadonly<HostConfig> = Object.create(null);\n\n/**\n * When defining conditions make sure that objects used by the function have\n * been instantiated.\n */\nexport type Condition = (config?: HostConfig) => boolean;\n\nexport const conditions = {\n  canDock: () => Boolean(Runtime.queryParam('can_dock')),\n};\n","// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n/* eslint-disable rulesdir/no-imperative-dom-api */\n\nimport * as I18n from '../../third_party/i18n/i18n.js';\nimport type * as Platform from '../platform/platform.js';\nimport * as Root from '../root/root.js';\n\nimport {DevToolsLocale} from './DevToolsLocale.js';\nimport type * as i18nTypes from './i18nTypes.js';\nimport {\n  BUNDLED_LOCALES as BUNDLED_LOCALES_GENERATED,\n  DEFAULT_LOCALE,\n  LOCAL_FETCH_PATTERN,\n  LOCALES,\n  REMOTE_FETCH_PATTERN,\n} from './locales.js';\n\nconst i18nInstance = new I18n.I18n.I18n(LOCALES, DEFAULT_LOCALE);\n\n// All the locales that are part of the DevTools bundle and should not be fetched\n// remotely.\nconst BUNDLED_LOCALES = new Set<string>([...BUNDLED_LOCALES_GENERATED]);\n\n/**\n * Look up the best available locale for the requested language through these fall backs:\n * - exact match\n * - progressively shorter prefixes (`de-CH-1996` -> `de-CH` -> `de`)\n * - the default locale ('en-US') if no match is found\n *\n * If `locale` isn't provided, the default is used.\n */\nexport function lookupClosestSupportedDevToolsLocale(locale: string): string {\n  return i18nInstance.lookupClosestSupportedLocale(locale);\n}\n\n/**\n * Returns a list of all supported DevTools locales, including pseudo locales.\n */\nexport function getAllSupportedDevToolsLocales(): string[] {\n  return [...i18nInstance.supportedLocales];\n}\n\n/**\n * Returns the Url from which a locale can be fetched. This depends on the\n * specific locale, as some are bundled with DevTools while others\n * have to be fetched remotely.\n */\nfunction getLocaleFetchUrl(locale: Intl.UnicodeBCP47LocaleIdentifier, location: string): string {\n  const remoteBase = Root.Runtime.getRemoteBase(location);\n  if (remoteBase?.version && !BUNDLED_LOCALES.has(locale)) {\n    return REMOTE_FETCH_PATTERN.replace('@HOST@', 'devtools://devtools')\n        .replace('@VERSION@', remoteBase.version)\n        .replace('@LOCALE@', locale);\n  }\n  const path = LOCAL_FETCH_PATTERN.replace('@LOCALE@', locale);\n  return new URL(path, import.meta.url).toString();\n}\n\n/**\n * Fetches the locale data of the specified locale.\n * Callers have to ensure that `locale` is an officially supported locale.\n * Depending whether a locale is present in `bundledLocales`, the data will be\n * fetched locally or remotely.\n */\nexport async function fetchAndRegisterLocaleData(\n    locale: Intl.UnicodeBCP47LocaleIdentifier, location = self.location.toString()): Promise<void> {\n  const localeDataTextPromise = fetch(getLocaleFetchUrl(locale, location)).then(result => result.json());\n  const timeoutPromise =\n      new Promise<never>((_, reject) => window.setTimeout(() => reject(new Error('timed out fetching locale')), 5000));\n  const localeData = await Promise.race([timeoutPromise, localeDataTextPromise]);\n  i18nInstance.registerLocaleData(locale, localeData);\n}\n\nexport function hasLocaleDataForTest(locale: Intl.UnicodeBCP47LocaleIdentifier): boolean {\n  return i18nInstance.hasLocaleDataForTest(locale);\n}\n\nexport function resetLocaleDataForTest(): void {\n  i18nInstance.resetLocaleDataForTest();\n}\n\n/**\n * Returns an anonymous function that wraps a call to retrieve a localized string.\n * This is introduced so that localized strings can be declared in environments where\n * the i18n system has not been configured and so, cannot be directly invoked. Instead,\n * strings are lazily localized when they are used. This is used for instance in the\n * meta files used to register module extensions.\n */\nexport function getLazilyComputedLocalizedString(\n    registeredStrings: I18n.LocalizedStringSet.RegisteredFileStrings, id: string, values: i18nTypes.Values = {}): () =>\n    Platform.UIString.LocalizedString {\n  return (): Platform.UIString.LocalizedString => getLocalizedString(registeredStrings, id, values);\n}\n\n/**\n * Retrieve the localized string.\n */\nexport function getLocalizedString(\n    registeredStrings: I18n.LocalizedStringSet.RegisteredFileStrings, id: string,\n    values: i18nTypes.Values = {}): Platform.UIString.LocalizedString {\n  return registeredStrings.getLocalizedStringSetFor(DevToolsLocale.instance().locale).getLocalizedString(id, values) as\n      Platform.UIString.LocalizedString;\n}\n\n/**\n * Register a file's UIStrings with i18n, return function to generate the string ids.\n */\nexport function registerUIStrings(\n    path: string, stringStructure: Record<string, string>): I18n.LocalizedStringSet.RegisteredFileStrings {\n  return i18nInstance.registerFileStrings(path, stringStructure);\n}\n\n/**\n * Returns a span element that may contains other DOM element as placeholders\n */\nexport function getFormatLocalizedString(\n    registeredStrings: I18n.LocalizedStringSet.RegisteredFileStrings, stringId: string,\n    placeholders: Record<string, Object>): HTMLSpanElement {\n  const formatter =\n      registeredStrings.getLocalizedStringSetFor(DevToolsLocale.instance().locale).getMessageFormatterFor(stringId);\n\n  const element = document.createElement('span');\n  for (const icuElement of formatter.getAst()) {\n    if (icuElement.type === /* argumentElement */ 1) {\n      const placeholderValue = placeholders[icuElement.value];\n      if (placeholderValue) {\n        element.append(placeholderValue as Node | string);\n      }\n    } else if ('value' in icuElement) {\n      element.append(String(icuElement.value));\n    }\n  }\n  return element;\n}\n\nexport function serializeUIString(string: string, values: Record<string, Object> = {}): string {\n  const serializedMessage = {string, values};\n  return JSON.stringify(serializedMessage);\n}\n\nexport function deserializeUIString(serializedMessage: string): i18nTypes.SerializedMessage {\n  if (!serializedMessage) {\n    return {string: '', values: {}} as i18nTypes.SerializedMessage;\n  }\n\n  return JSON.parse(serializedMessage) as i18nTypes.SerializedMessage;\n}\n\n/**\n * Use this function in places where a `LocalizedString` is expected but the\n * term/phrase you want to use does not require translation.\n */\nexport function lockedString(str: string): Platform.UIString.LocalizedString {\n  return str as Platform.UIString.LocalizedString;\n}\n\n/**\n * Same as `lockedString` but for places where `i18nLazyString` would be used otherwise.\n */\nexport function lockedLazyString(str: string): () => Platform.UIString.LocalizedString {\n  return (): Platform.UIString.LocalizedString => str as Platform.UIString.LocalizedString;\n}\n\n/**\n * Returns a string of the form:\n *   \"German (Austria) - Deutsch (sterreich)\"\n * where the former locale representation is written in the currently enabled DevTools\n * locale and the latter locale representation is written in the locale of `localeString`.\n *\n * Should the two locales match (i.e. have the same language) then the latter locale\n * representation is written in English.\n */\nexport function getLocalizedLanguageRegion(\n    localeString: Intl.UnicodeBCP47LocaleIdentifier,\n    devtoolsLocale: DevToolsLocale): Platform.UIString.LocalizedString {\n  const locale = new Intl.Locale(localeString);\n  const {language, baseName} = locale;\n  const devtoolsLoc = new Intl.Locale(devtoolsLocale.locale);\n  const targetLanguage = language === devtoolsLoc.language ? 'en' : baseName;\n  const languageInCurrentLocale = new Intl.DisplayNames([devtoolsLocale.locale], {type: 'language'}).of(language);\n  const languageInTargetLocale = new Intl.DisplayNames([targetLanguage], {type: 'language'}).of(language);\n\n  let wrappedRegionInCurrentLocale = '';\n  let wrappedRegionInTargetLocale = '';\n\n  if (locale.region) {\n    const regionInCurrentLocale =\n        new Intl.DisplayNames([devtoolsLocale.locale], {type: 'region', style: 'short'}).of(locale.region);\n    const regionInTargetLocale =\n        new Intl.DisplayNames([targetLanguage], {type: 'region', style: 'short'}).of(locale.region);\n    wrappedRegionInCurrentLocale = ` (${regionInCurrentLocale})`;\n    wrappedRegionInTargetLocale = ` (${regionInTargetLocale})`;\n  }\n\n  return `${languageInCurrentLocale}${wrappedRegionInCurrentLocale} - ${languageInTargetLocale}${\n             wrappedRegionInTargetLocale}` as Platform.UIString.LocalizedString;\n}\n","/*\n * Copyright (C) 2011 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* eslint-disable rulesdir/prefer-private-class-members */\n\nimport * as i18n from '../../core/i18n/i18n.js';\nimport * as Platform from '../../core/platform/platform.js';\nimport * as HeapSnapshotModel from '../../models/heap_snapshot_model/heap_snapshot_model.js';\n\nimport {AllocationProfile} from './AllocationProfile.js';\nimport type {HeapSnapshotWorkerDispatcher} from './HeapSnapshotWorkerDispatcher.js';\n\nexport interface HeapSnapshotItem {\n  itemIndex(): number;\n\n  serialize(): Object;\n}\n\nexport class HeapSnapshotEdge implements HeapSnapshotItem {\n  snapshot: HeapSnapshot;\n  protected readonly edges: Platform.TypedArrayUtilities.BigUint32Array;\n  edgeIndex: number;\n  constructor(snapshot: HeapSnapshot, edgeIndex?: number) {\n    this.snapshot = snapshot;\n    this.edges = snapshot.containmentEdges;\n    this.edgeIndex = edgeIndex || 0;\n  }\n\n  clone(): HeapSnapshotEdge {\n    return new HeapSnapshotEdge(this.snapshot, this.edgeIndex);\n  }\n\n  hasStringName(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  name(): string {\n    throw new Error('Not implemented');\n  }\n\n  node(): HeapSnapshotNode {\n    return this.snapshot.createNode(this.nodeIndex());\n  }\n\n  nodeIndex(): number {\n    if (typeof this.snapshot.edgeToNodeOffset === 'undefined') {\n      throw new Error('edgeToNodeOffset is undefined');\n    }\n\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeToNodeOffset);\n  }\n\n  toString(): string {\n    return 'HeapSnapshotEdge: ' + this.name();\n  }\n\n  type(): string {\n    return this.snapshot.edgeTypes[this.rawType()];\n  }\n\n  itemIndex(): number {\n    return this.edgeIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Edge {\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), this.node().serialize(), this.type(), this.edgeIndex);\n  }\n\n  rawType(): number {\n    if (typeof this.snapshot.edgeTypeOffset === 'undefined') {\n      throw new Error('edgeTypeOffset is undefined');\n    }\n\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeTypeOffset);\n  }\n\n  isInternal(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isInvisible(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isWeak(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  getValueForSorting(_fieldName: string): number {\n    throw new Error('Not implemented');\n  }\n\n  nameIndex(): number {\n    throw new Error('Not implemented');\n  }\n}\n\nexport interface HeapSnapshotItemIterator {\n  hasNext(): boolean;\n\n  item(): HeapSnapshotItem;\n\n  next(): void;\n}\n\nexport interface HeapSnapshotItemIndexProvider {\n  itemForIndex(newIndex: number): HeapSnapshotItem;\n}\n\nexport class HeapSnapshotNodeIndexProvider implements HeapSnapshotItemIndexProvider {\n  #node: HeapSnapshotNode;\n  constructor(snapshot: HeapSnapshot) {\n    this.#node = snapshot.createNode();\n  }\n\n  itemForIndex(index: number): HeapSnapshotNode {\n    this.#node.nodeIndex = index;\n    return this.#node;\n  }\n}\n\nexport class HeapSnapshotEdgeIndexProvider implements HeapSnapshotItemIndexProvider {\n  #edge: JSHeapSnapshotEdge;\n  constructor(snapshot: HeapSnapshot) {\n    this.#edge = snapshot.createEdge(0);\n  }\n\n  itemForIndex(index: number): HeapSnapshotEdge {\n    this.#edge.edgeIndex = index;\n    return this.#edge;\n  }\n}\n\nexport class HeapSnapshotRetainerEdgeIndexProvider implements HeapSnapshotItemIndexProvider {\n  readonly #retainerEdge: JSHeapSnapshotRetainerEdge;\n  constructor(snapshot: HeapSnapshot) {\n    this.#retainerEdge = snapshot.createRetainingEdge(0);\n  }\n\n  itemForIndex(index: number): HeapSnapshotRetainerEdge {\n    this.#retainerEdge.setRetainerIndex(index);\n    return this.#retainerEdge;\n  }\n}\n\nexport class HeapSnapshotEdgeIterator implements HeapSnapshotItemIterator {\n  readonly #sourceNode: HeapSnapshotNode;\n  edge: JSHeapSnapshotEdge;\n  constructor(node: HeapSnapshotNode) {\n    this.#sourceNode = node;\n    this.edge = node.snapshot.createEdge(node.edgeIndexesStart());\n  }\n\n  hasNext(): boolean {\n    return this.edge.edgeIndex < this.#sourceNode.edgeIndexesEnd();\n  }\n\n  item(): HeapSnapshotEdge {\n    return this.edge;\n  }\n\n  next(): void {\n    if (typeof this.edge.snapshot.edgeFieldsCount === 'undefined') {\n      throw new Error('edgeFieldsCount is undefined');\n    }\n    this.edge.edgeIndex += this.edge.snapshot.edgeFieldsCount;\n  }\n}\n\nexport class HeapSnapshotRetainerEdge implements HeapSnapshotItem {\n  protected snapshot: HeapSnapshot;\n  #retainerIndexInternal!: number;\n  #globalEdgeIndex!: number;\n  #retainingNodeIndex?: number;\n  #edgeInstance?: JSHeapSnapshotEdge|null;\n  #nodeInstance?: HeapSnapshotNode|null;\n  constructor(snapshot: HeapSnapshot, retainerIndex: number) {\n    this.snapshot = snapshot;\n    this.setRetainerIndex(retainerIndex);\n  }\n\n  clone(): HeapSnapshotRetainerEdge {\n    return new HeapSnapshotRetainerEdge(this.snapshot, this.retainerIndex());\n  }\n\n  hasStringName(): boolean {\n    return this.edge().hasStringName();\n  }\n\n  name(): string {\n    return this.edge().name();\n  }\n\n  nameIndex(): number {\n    return this.edge().nameIndex();\n  }\n\n  node(): HeapSnapshotNode {\n    return this.nodeInternal();\n  }\n\n  nodeIndex(): number {\n    if (typeof this.#retainingNodeIndex === 'undefined') {\n      throw new Error('retainingNodeIndex is undefined');\n    }\n\n    return this.#retainingNodeIndex;\n  }\n\n  retainerIndex(): number {\n    return this.#retainerIndexInternal;\n  }\n\n  setRetainerIndex(retainerIndex: number): void {\n    if (retainerIndex === this.#retainerIndexInternal) {\n      return;\n    }\n\n    if (!this.snapshot.retainingEdges || !this.snapshot.retainingNodes) {\n      throw new Error('Snapshot does not contain retaining edges or retaining nodes');\n    }\n\n    this.#retainerIndexInternal = retainerIndex;\n    this.#globalEdgeIndex = this.snapshot.retainingEdges[retainerIndex];\n    this.#retainingNodeIndex = this.snapshot.retainingNodes[retainerIndex];\n    this.#edgeInstance = null;\n    this.#nodeInstance = null;\n  }\n\n  set edgeIndex(edgeIndex: number) {\n    this.setRetainerIndex(edgeIndex);\n  }\n\n  private nodeInternal(): HeapSnapshotNode {\n    if (!this.#nodeInstance) {\n      this.#nodeInstance = this.snapshot.createNode(this.#retainingNodeIndex);\n    }\n    return this.#nodeInstance;\n  }\n\n  protected edge(): JSHeapSnapshotEdge {\n    if (!this.#edgeInstance) {\n      this.#edgeInstance = this.snapshot.createEdge(this.#globalEdgeIndex);\n    }\n    return this.#edgeInstance;\n  }\n\n  toString(): string {\n    return this.edge().toString();\n  }\n\n  itemIndex(): number {\n    return this.#retainerIndexInternal;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Edge {\n    const node = this.node();\n    const serializedNode = node.serialize();\n    serializedNode.distance = this.#distance();\n    serializedNode.ignored = this.snapshot.isNodeIgnoredInRetainersView(node.nodeIndex);\n\n    return new HeapSnapshotModel.HeapSnapshotModel.Edge(\n        this.name(), serializedNode, this.type(), this.#globalEdgeIndex);\n  }\n\n  type(): string {\n    return this.edge().type();\n  }\n\n  isInternal(): boolean {\n    return this.edge().isInternal();\n  }\n\n  getValueForSorting(fieldName: string): number {\n    if (fieldName === '!edgeDistance') {\n      return this.#distance();\n    }\n    throw new Error('Invalid field name');\n  }\n\n  #distance(): number {\n    if (this.snapshot.isEdgeIgnoredInRetainersView(this.#globalEdgeIndex)) {\n      return HeapSnapshotModel.HeapSnapshotModel.baseUnreachableDistance;\n    }\n    return this.node().distanceForRetainersView();\n  }\n}\n\nexport class HeapSnapshotRetainerEdgeIterator implements HeapSnapshotItemIterator {\n  readonly #retainersEnd: number;\n  retainer: JSHeapSnapshotRetainerEdge;\n  constructor(retainedNode: HeapSnapshotNode) {\n    const snapshot = retainedNode.snapshot;\n    const retainedNodeOrdinal = retainedNode.ordinal();\n    if (!snapshot.firstRetainerIndex) {\n      throw new Error('Snapshot does not contain firstRetainerIndex');\n    }\n    const retainerIndex = snapshot.firstRetainerIndex[retainedNodeOrdinal];\n    this.#retainersEnd = snapshot.firstRetainerIndex[retainedNodeOrdinal + 1];\n    this.retainer = snapshot.createRetainingEdge(retainerIndex);\n  }\n\n  hasNext(): boolean {\n    return this.retainer.retainerIndex() < this.#retainersEnd;\n  }\n\n  item(): HeapSnapshotRetainerEdge {\n    return this.retainer;\n  }\n\n  next(): void {\n    this.retainer.setRetainerIndex(this.retainer.retainerIndex() + 1);\n  }\n}\n\nexport class HeapSnapshotNode implements HeapSnapshotItem {\n  snapshot: HeapSnapshot;\n  nodeIndex: number;\n  constructor(snapshot: HeapSnapshot, nodeIndex?: number) {\n    this.snapshot = snapshot;\n    this.nodeIndex = nodeIndex || 0;\n  }\n\n  distance(): number {\n    return this.snapshot.nodeDistances[this.nodeIndex / this.snapshot.nodeFieldCount];\n  }\n\n  distanceForRetainersView(): number {\n    return this.snapshot.getDistanceForRetainersView(this.nodeIndex);\n  }\n\n  className(): string {\n    return this.snapshot.strings[this.classIndex()];\n  }\n\n  classIndex(): number {\n    return this.#detachednessAndClassIndex() >>> SHIFT_FOR_CLASS_INDEX;\n  }\n\n  // Returns a key which can uniquely describe both the class name for this node\n  // and its Location, if relevant. These keys are meant to be cheap to produce,\n  // so that building aggregates is fast. These keys are NOT the same as the\n  // keys exposed to the frontend by functions such as aggregatesWithFilter and\n  // aggregatesForDiff.\n  classKeyInternal(): string|number {\n    // It is common for multiple JavaScript constructors to have the same\n    // name, so the class key includes the location if available for nodes of\n    // type 'object'.\n    //\n    // JavaScript Functions (node type 'closure') also have locations, but it\n    // would not be helpful to split them into categories by location because\n    // many of those categories would have only one instance.\n    if (this.rawType() !== this.snapshot.nodeObjectType) {\n      return this.classIndex();\n    }\n    const location = this.snapshot.getLocation(this.nodeIndex);\n    return location ? `${location.scriptId},${location.lineNumber},${location.columnNumber},${this.className()}` :\n                      this.classIndex();\n  }\n\n  setClassIndex(index: number): void {\n    let value = this.#detachednessAndClassIndex();\n    value &= BITMASK_FOR_DOM_LINK_STATE;        // Clear previous class index.\n    value |= (index << SHIFT_FOR_CLASS_INDEX);  // Set new class index.\n    this.#setDetachednessAndClassIndex(value);\n    if (this.classIndex() !== index) {\n      throw new Error('String index overflow');\n    }\n  }\n\n  dominatorIndex(): number {\n    const nodeFieldCount = this.snapshot.nodeFieldCount;\n    return this.snapshot.dominatorsTree[this.nodeIndex / this.snapshot.nodeFieldCount] * nodeFieldCount;\n  }\n\n  edges(): HeapSnapshotEdgeIterator {\n    return new HeapSnapshotEdgeIterator(this);\n  }\n\n  edgesCount(): number {\n    return (this.edgeIndexesEnd() - this.edgeIndexesStart()) / this.snapshot.edgeFieldsCount;\n  }\n\n  id(): number {\n    throw new Error('Not implemented');\n  }\n\n  rawName(): string {\n    return this.snapshot.strings[this.rawNameIndex()];\n  }\n\n  isRoot(): boolean {\n    return this.nodeIndex === this.snapshot.rootNodeIndex;\n  }\n\n  isUserRoot(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isHidden(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isArray(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isSynthetic(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  isDocumentDOMTreesRoot(): boolean {\n    throw new Error('Not implemented');\n  }\n\n  name(): string {\n    return this.rawName();\n  }\n\n  retainedSize(): number {\n    return this.snapshot.retainedSizes[this.ordinal()];\n  }\n\n  retainers(): HeapSnapshotRetainerEdgeIterator {\n    return new HeapSnapshotRetainerEdgeIterator(this);\n  }\n\n  retainersCount(): number {\n    const snapshot = this.snapshot;\n    const ordinal = this.ordinal();\n    return snapshot.firstRetainerIndex[ordinal + 1] - snapshot.firstRetainerIndex[ordinal];\n  }\n\n  selfSize(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeSelfSizeOffset);\n  }\n\n  type(): string {\n    return this.snapshot.nodeTypes[this.rawType()];\n  }\n\n  traceNodeId(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeTraceNodeIdOffset);\n  }\n\n  itemIndex(): number {\n    return this.nodeIndex;\n  }\n\n  serialize(): HeapSnapshotModel.HeapSnapshotModel.Node {\n    return new HeapSnapshotModel.HeapSnapshotModel.Node(\n        this.id(), this.name(), this.distance(), this.nodeIndex, this.retainedSize(), this.selfSize(), this.type());\n  }\n\n  rawNameIndex(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeNameOffset);\n  }\n\n  edgeIndexesStart(): number {\n    return this.snapshot.firstEdgeIndexes[this.ordinal()];\n  }\n\n  edgeIndexesEnd(): number {\n    return this.snapshot.firstEdgeIndexes[this.ordinal() + 1];\n  }\n\n  ordinal(): number {\n    return this.nodeIndex / this.snapshot.nodeFieldCount;\n  }\n\n  nextNodeIndex(): number {\n    return this.nodeIndex + this.snapshot.nodeFieldCount;\n  }\n\n  rawType(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeTypeOffset);\n  }\n\n  isFlatConsString(): boolean {\n    if (this.rawType() !== this.snapshot.nodeConsStringType) {\n      return false;\n    }\n    for (let iter = this.edges(); iter.hasNext(); iter.next()) {\n      const edge = iter.edge;\n      if (!edge.isInternal()) {\n        continue;\n      }\n      const edgeName = edge.name();\n      if ((edgeName === 'first' || edgeName === 'second') && edge.node().name() === '') {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  #detachednessAndClassIndex(): number {\n    const {snapshot, nodeIndex} = this;\n    const nodeDetachednessAndClassIndexOffset = snapshot.nodeDetachednessAndClassIndexOffset;\n    return nodeDetachednessAndClassIndexOffset !== -1 ?\n        snapshot.nodes.getValue(nodeIndex + nodeDetachednessAndClassIndexOffset) :\n        (snapshot.detachednessAndClassIndexArray as Uint32Array)[nodeIndex / snapshot.nodeFieldCount];\n  }\n\n  #setDetachednessAndClassIndex(value: number): void {\n    const {snapshot, nodeIndex} = this;\n    const nodeDetachednessAndClassIndexOffset = snapshot.nodeDetachednessAndClassIndexOffset;\n    if (nodeDetachednessAndClassIndexOffset !== -1) {\n      snapshot.nodes.setValue(nodeIndex + nodeDetachednessAndClassIndexOffset, value);\n    } else {\n      (snapshot.detachednessAndClassIndexArray as Uint32Array)[nodeIndex / snapshot.nodeFieldCount] = value;\n    }\n  }\n\n  detachedness(): DOMLinkState {\n    return this.#detachednessAndClassIndex() & BITMASK_FOR_DOM_LINK_STATE;\n  }\n\n  setDetachedness(detachedness: DOMLinkState): void {\n    let value = this.#detachednessAndClassIndex();\n    value &= ~BITMASK_FOR_DOM_LINK_STATE;  // Clear the old bits.\n    value |= detachedness;                 // Set the new bits.\n    this.#setDetachednessAndClassIndex(value);\n  }\n}\n\nexport class HeapSnapshotNodeIterator implements HeapSnapshotItemIterator {\n  node: HeapSnapshotNode;\n  readonly #nodesLength: number;\n  constructor(node: HeapSnapshotNode) {\n    this.node = node;\n    this.#nodesLength = node.snapshot.nodes.length;\n  }\n\n  hasNext(): boolean {\n    return this.node.nodeIndex < this.#nodesLength;\n  }\n\n  item(): HeapSnapshotNode {\n    return this.node;\n  }\n\n  next(): void {\n    this.node.nodeIndex = this.node.nextNodeIndex();\n  }\n}\n\nexport class HeapSnapshotIndexRangeIterator implements HeapSnapshotItemIterator {\n  readonly #itemProvider: HeapSnapshotItemIndexProvider;\n  readonly #indexes: number[]|Uint32Array;\n  #position: number;\n  constructor(itemProvider: HeapSnapshotItemIndexProvider, indexes: number[]|Uint32Array) {\n    this.#itemProvider = itemProvider;\n    this.#indexes = indexes;\n    this.#position = 0;\n  }\n\n  hasNext(): boolean {\n    return this.#position < this.#indexes.length;\n  }\n\n  item(): HeapSnapshotItem {\n    const index = this.#indexes[this.#position];\n    return this.#itemProvider.itemForIndex(index);\n  }\n\n  next(): void {\n    ++this.#position;\n  }\n}\n\nexport class HeapSnapshotFilteredIterator implements HeapSnapshotItemIterator {\n  #iterator: HeapSnapshotItemIterator;\n  #filter: ((arg0: HeapSnapshotItem) => boolean)|undefined;\n  constructor(iterator: HeapSnapshotItemIterator, filter?: ((arg0: HeapSnapshotItem) => boolean)) {\n    this.#iterator = iterator;\n    this.#filter = filter;\n    this.skipFilteredItems();\n  }\n\n  hasNext(): boolean {\n    return this.#iterator.hasNext();\n  }\n\n  item(): HeapSnapshotItem {\n    return this.#iterator.item();\n  }\n\n  next(): void {\n    this.#iterator.next();\n    this.skipFilteredItems();\n  }\n\n  private skipFilteredItems(): void {\n    while (this.#iterator.hasNext() && this.#filter && !this.#filter(this.#iterator.item())) {\n      this.#iterator.next();\n    }\n  }\n}\n\nexport class HeapSnapshotProgress {\n  readonly #dispatcher: HeapSnapshotWorkerDispatcher|undefined;\n  constructor(dispatcher?: HeapSnapshotWorkerDispatcher) {\n    this.#dispatcher = dispatcher;\n  }\n\n  updateStatus(status: string): void {\n    this.sendUpdateEvent(i18n.i18n.serializeUIString(status));\n  }\n\n  updateProgress(title: string, value: number, total: number): void {\n    const percentValue = ((total ? (value / total) : 0) * 100).toFixed(0);\n    this.sendUpdateEvent(i18n.i18n.serializeUIString(title, {PH1: percentValue}));\n  }\n\n  reportProblem(error: string): void {\n    // May be undefined in tests.\n    if (this.#dispatcher) {\n      this.#dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.BrokenSnapshot, error);\n    }\n  }\n\n  private sendUpdateEvent(serializedText: string): void {\n    // May be undefined in tests.\n    if (this.#dispatcher) {\n      this.#dispatcher.sendEvent(HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent.Update, serializedText);\n    }\n  }\n}\n\n// An \"interface\" to be used when classifying plain JS objects in the snapshot.\n// An object matches the interface if it contains every listed property (even\n// if it also contains extra properties).\ninterface InterfaceDefinition {\n  name: string;\n  properties: string[];\n}\n\ntype HeapSnapshotProblemReport = Array<string|number>;\nfunction appendToProblemReport(report: HeapSnapshotProblemReport, messageOrNodeIndex: string|number): void {\n  if (report.length > 100) {\n    return;\n  }\n  report.push(messageOrNodeIndex);\n}\nfunction formatProblemReport(snapshot: HeapSnapshot, report: HeapSnapshotProblemReport): string {\n  const node = snapshot.rootNode();\n  return report\n      .map(messageOrNodeIndex => {\n        if (typeof messageOrNodeIndex === 'string') {\n          return messageOrNodeIndex;\n        }\n        node.nodeIndex = messageOrNodeIndex;\n        return `${node.name()} @${node.id()}`;\n      })\n      .join('\\n  ');\n}\nfunction reportProblemToPrimaryWorker(problemReport: HeapSnapshotProblemReport, port: MessagePort): void {\n  port.postMessage({problemReport});\n}\n\nexport interface Profile {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  root_index: number;\n  nodes: Platform.TypedArrayUtilities.BigUint32Array;\n  edges: Platform.TypedArrayUtilities.BigUint32Array;\n  snapshot: HeapSnapshotHeader;\n  samples: number[];\n  strings: string[];\n  locations: number[];\n  trace_function_infos: Uint32Array;\n  trace_tree: Object;\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport type LiveObjects = Record<number, {count: number, size: number, ids: number[]}>;\n\n// The first batch of data sent from the primary worker to the secondary.\ninterface SecondaryInitArgumentsStep1 {\n  // For each edge ordinal, this array contains the ordinal of the pointed-to node.\n  edgeToNodeOrdinals: Uint32Array;\n  // A copy of HeapSnapshot.firstEdgeIndexes. For each node ordinal, this array\n  // contains the edge index of the first outgoing edge.\n  firstEdgeIndexes: Uint32Array;\n  nodeCount: number;\n  edgeFieldsCount: number;\n  nodeFieldCount: number;\n}\n\n// The second batch of data sent from the primary worker to the secondary.\ninterface SecondaryInitArgumentsStep2 {\n  rootNodeOrdinal: number;\n  // An array with one bit per edge, where each bit indicates whether the edge\n  // should be used when computing dominators.\n  essentialEdgesBuffer: ArrayBuffer;\n}\n\n// The third batch of data sent from the primary worker to the secondary.\ninterface SecondaryInitArgumentsStep3 {\n  // For each node ordinal, this array contains the node's shallow size.\n  nodeSelfSizes: Uint32Array;\n}\n\ntype ArgumentsToBuildRetainers = SecondaryInitArgumentsStep1;\n\ninterface Retainers {\n  // For each node ordinal, this array contains the index of the first retaining edge\n  // in the retainingEdges and retainingNodes arrays.\n  firstRetainerIndex: Uint32Array;\n  // For each retaining edge, this array contains the \"from\" node's index.\n  retainingNodes: Uint32Array;\n  // For each retaining edge, this array contains the index in containmentEdges\n  // where you can find other info about the edge, such as its type and name.\n  retainingEdges: Uint32Array;\n}\n\ninterface ArgumentsToComputeDominatorsAndRetainedSizes extends SecondaryInitArgumentsStep1, Retainers,\n                                                               SecondaryInitArgumentsStep2 {\n  // For each edge ordinal, this bit vector contains whether the edge\n  // should be used when computing dominators.\n  essentialEdges: Platform.TypedArrayUtilities.BitVector;\n  // A message port for reporting problems to the primary worker.\n  port: MessagePort;\n  // For each node ordinal, this array will contain the node's shallow size.\n  nodeSelfSizesPromise: Promise<Uint32Array>;\n}\n\ninterface DominatorsAndRetainedSizes {\n  // For each node ordinal, this array contains the ordinal of its immediate dominating node.\n  dominatorsTree: Uint32Array;\n  // For each node ordinal, this array contains the size of the subgraph it dominates, including its own size.\n  retainedSizes: Float64Array;\n}\n\ninterface ArgumentsToBuildDominatedNodes extends ArgumentsToComputeDominatorsAndRetainedSizes,\n                                                 DominatorsAndRetainedSizes {}\n\ninterface DominatedNodes {\n  // For each node ordinal, the index of its first child node in dominatedNodes.\n  // Together with dominatedNodes, this allows traversing down the dominators tree,\n  // whereas dominatorsTree allows upward traversal.\n  firstDominatedNodeIndex: Uint32Array;\n  // Node indexes of child nodes in the dominator tree.\n  dominatedNodes: Uint32Array;\n}\n\n// The data transferred from the secondary worker to the primary.\ninterface ResultsFromSecondWorker extends Retainers, DominatorsAndRetainedSizes, DominatedNodes {}\n\n// Initialization work is split into two threads. This class is the entry point\n// for work done by the second thread.\nexport class SecondaryInitManager {\n  argsStep1: Promise<SecondaryInitArgumentsStep1>;\n  argsStep2: Promise<SecondaryInitArgumentsStep2>;\n  argsStep3: Promise<SecondaryInitArgumentsStep3>;\n  constructor(port: MessagePort) {\n    const {promise: argsStep1, resolve: resolveArgsStep1} = Promise.withResolvers<SecondaryInitArgumentsStep1>();\n    this.argsStep1 = argsStep1;\n    const {promise: argsStep2, resolve: resolveArgsStep2} = Promise.withResolvers<SecondaryInitArgumentsStep2>();\n    this.argsStep2 = argsStep2;\n    const {promise: argsStep3, resolve: resolveArgsStep3} = Promise.withResolvers<SecondaryInitArgumentsStep3>();\n    this.argsStep3 = argsStep3;\n    port.onmessage = e => {\n      const data = e.data;\n      switch (data.step) {\n        case 1:\n          resolveArgsStep1(data.args);\n          break;\n        case 2:\n          resolveArgsStep2(data.args);\n          break;\n        case 3:\n          resolveArgsStep3(data.args);\n          break;\n      }\n    };\n    void this.initialize(port);\n  }\n\n  private async getNodeSelfSizes(): Promise<Uint32Array> {\n    return (await this.argsStep3).nodeSelfSizes;\n  }\n\n  private async initialize(port: MessagePort): Promise<void> {\n    try {\n      const argsStep1 = await this.argsStep1;\n      const retainers = HeapSnapshot.buildRetainers(argsStep1);\n      const argsStep2 = await this.argsStep2;\n      const args = {\n        ...argsStep2,\n        ...argsStep1,\n        ...retainers,\n        essentialEdges: Platform.TypedArrayUtilities.createBitVector(argsStep2.essentialEdgesBuffer),\n        port,\n        nodeSelfSizesPromise: this.getNodeSelfSizes()\n      };\n      const dominatorsAndRetainedSizes = await HeapSnapshot.calculateDominatorsAndRetainedSizes(args);\n      const dominatedNodesOutputs = HeapSnapshot.buildDominatedNodes({...args, ...dominatorsAndRetainedSizes});\n      const results: ResultsFromSecondWorker = {\n        ...retainers,\n        ...dominatorsAndRetainedSizes,\n        ...dominatedNodesOutputs,\n      };\n      port.postMessage({resultsFromSecondWorker: results}, {\n        transfer: [\n          results.dominatorsTree.buffer,\n          results.firstRetainerIndex.buffer,\n          results.retainedSizes.buffer,\n          results.retainingEdges.buffer,\n          results.retainingNodes.buffer,\n          results.dominatedNodes.buffer,\n          results.firstDominatedNodeIndex.buffer,\n        ]\n      });\n    } catch (e) {\n      port.postMessage({error: e + '\\n' + e?.stack});\n    }\n  }\n}\n\n/**\n * DOM node link state.\n */\nconst enum DOMLinkState {\n  UNKNOWN = 0,\n  ATTACHED = 1,\n  DETACHED = 2,\n}\nconst BITMASK_FOR_DOM_LINK_STATE = 3;\n\n// The class index is stored in the upper 30 bits of the detachedness field.\nconst SHIFT_FOR_CLASS_INDEX = 2;\n\n// After this many properties, inferInterfaceDefinitions can stop adding more\n// properties to an interface definition if the name is getting too long.\nconst MIN_INTERFACE_PROPERTY_COUNT = 1;\n\n// The maximum length of an interface name produced by inferInterfaceDefinitions.\n// This limit can be exceeded if the first MIN_INTERFACE_PROPERTY_COUNT property\n// names are long.\nconst MAX_INTERFACE_NAME_LENGTH = 120;\n\n// Each interface definition produced by inferInterfaceDefinitions will match at\n// least this many objects. There's no point in defining interfaces which match\n// only a single object.\nconst MIN_OBJECT_COUNT_PER_INTERFACE = 2;\n\n// Each interface definition produced by inferInterfaceDefinitions should\n// match at least 1 out of 1000 Objects in the heap. Otherwise, we end up with a\n// long tail of unpopular interfaces that don't help analysis.\nconst MIN_OBJECT_PROPORTION_PER_INTERFACE = 1000;\n\nexport abstract class HeapSnapshot {\n  nodes: Platform.TypedArrayUtilities.BigUint32Array;\n  containmentEdges: Platform.TypedArrayUtilities.BigUint32Array;\n  readonly #metaNode: HeapSnapshotMetaInfo;\n  readonly #rawSamples: number[];\n  #samples: HeapSnapshotModel.HeapSnapshotModel.Samples|null = null;\n  strings: string[];\n  readonly #locations: number[];\n  readonly #progress: HeapSnapshotProgress;\n  readonly #noDistance = -5;\n  rootNodeIndexInternal = 0;\n  #snapshotDiffs: Record<string, Record<string, HeapSnapshotModel.HeapSnapshotModel.Diff>> = {};\n  #aggregatesForDiffInternal?: {\n    interfaceDefinitions: string,\n    aggregates: Record<string, HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff>,\n  };\n  #aggregates: Record<string, Record<string, AggregatedInfo>> = {};\n  #aggregatesSortedFlags: Record<string, boolean> = {};\n  profile: Profile;\n  nodeTypeOffset!: number;\n  nodeNameOffset!: number;\n  nodeIdOffset!: number;\n  nodeSelfSizeOffset!: number;\n  #nodeEdgeCountOffset!: number;\n  nodeTraceNodeIdOffset!: number;\n  nodeFieldCount!: number;\n  nodeTypes!: string[];\n  nodeArrayType!: number;\n  nodeHiddenType!: number;\n  nodeObjectType!: number;\n  nodeNativeType!: number;\n  nodeStringType!: number;\n  nodeConsStringType!: number;\n  nodeSlicedStringType!: number;\n  nodeCodeType!: number;\n  nodeSyntheticType!: number;\n  nodeClosureType!: number;\n  nodeRegExpType!: number;\n  edgeFieldsCount!: number;\n  edgeTypeOffset!: number;\n  edgeNameOffset!: number;\n  edgeToNodeOffset!: number;\n  edgeTypes!: string[];\n  edgeElementType!: number;\n  edgeHiddenType!: number;\n  edgeInternalType!: number;\n  edgeShortcutType!: number;\n  edgeWeakType!: number;\n  edgeInvisibleType!: number;\n  edgePropertyType!: number;\n  #locationIndexOffset!: number;\n  #locationScriptIdOffset!: number;\n  #locationLineOffset!: number;\n  #locationColumnOffset!: number;\n  #locationFieldCount!: number;\n  nodeCount!: number;\n  #edgeCount!: number;\n  retainedSizes!: Float64Array;\n  firstEdgeIndexes!: Uint32Array;\n  retainingNodes!: Uint32Array;\n  retainingEdges!: Uint32Array;\n  firstRetainerIndex!: Uint32Array;\n  nodeDistances!: Int32Array;\n  firstDominatedNodeIndex!: Uint32Array;\n  dominatedNodes!: Uint32Array;\n  dominatorsTree!: Uint32Array;\n  #allocationProfile!: AllocationProfile;\n  nodeDetachednessAndClassIndexOffset!: number;\n  #locationMap!: Map<number, HeapSnapshotModel.HeapSnapshotModel.Location>;\n  #ignoredNodesInRetainersView = new Set<number>();\n  #ignoredEdgesInRetainersView = new Set<number>();\n  #nodeDistancesForRetainersView: Int32Array|undefined;\n  #edgeNamesThatAreNotWeakMaps: Platform.TypedArrayUtilities.BitVector;\n  detachednessAndClassIndexArray?: Uint32Array;\n  #interfaceNames = new Map<string, number>();\n  #interfaceDefinitions?: InterfaceDefinition[];\n\n  constructor(profile: Profile, progress: HeapSnapshotProgress) {\n    this.nodes = profile.nodes;\n    this.containmentEdges = profile.edges;\n    this.#metaNode = profile.snapshot.meta;\n    this.#rawSamples = profile.samples;\n    this.strings = profile.strings;\n    this.#locations = profile.locations;\n    this.#progress = progress;\n\n    if (profile.snapshot.root_index) {\n      this.rootNodeIndexInternal = profile.snapshot.root_index;\n    }\n\n    this.profile = profile;\n    this.#edgeNamesThatAreNotWeakMaps = Platform.TypedArrayUtilities.createBitVector(this.strings.length);\n  }\n\n  async initialize(secondWorker: MessagePort): Promise<void> {\n    const meta = this.#metaNode;\n\n    this.nodeTypeOffset = meta.node_fields.indexOf('type');\n    this.nodeNameOffset = meta.node_fields.indexOf('name');\n    this.nodeIdOffset = meta.node_fields.indexOf('id');\n    this.nodeSelfSizeOffset = meta.node_fields.indexOf('self_size');\n    this.#nodeEdgeCountOffset = meta.node_fields.indexOf('edge_count');\n    this.nodeTraceNodeIdOffset = meta.node_fields.indexOf('trace_node_id');\n    this.nodeDetachednessAndClassIndexOffset = meta.node_fields.indexOf('detachedness');\n    this.nodeFieldCount = meta.node_fields.length;\n\n    this.nodeTypes = meta.node_types[this.nodeTypeOffset];\n    this.nodeArrayType = this.nodeTypes.indexOf('array');\n    this.nodeHiddenType = this.nodeTypes.indexOf('hidden');\n    this.nodeObjectType = this.nodeTypes.indexOf('object');\n    this.nodeNativeType = this.nodeTypes.indexOf('native');\n    this.nodeStringType = this.nodeTypes.indexOf('string');\n    this.nodeConsStringType = this.nodeTypes.indexOf('concatenated string');\n    this.nodeSlicedStringType = this.nodeTypes.indexOf('sliced string');\n    this.nodeCodeType = this.nodeTypes.indexOf('code');\n    this.nodeSyntheticType = this.nodeTypes.indexOf('synthetic');\n    this.nodeClosureType = this.nodeTypes.indexOf('closure');\n    this.nodeRegExpType = this.nodeTypes.indexOf('regexp');\n\n    this.edgeFieldsCount = meta.edge_fields.length;\n    this.edgeTypeOffset = meta.edge_fields.indexOf('type');\n    this.edgeNameOffset = meta.edge_fields.indexOf('name_or_index');\n    this.edgeToNodeOffset = meta.edge_fields.indexOf('to_node');\n\n    this.edgeTypes = meta.edge_types[this.edgeTypeOffset];\n    this.edgeTypes.push('invisible');\n    this.edgeElementType = this.edgeTypes.indexOf('element');\n    this.edgeHiddenType = this.edgeTypes.indexOf('hidden');\n    this.edgeInternalType = this.edgeTypes.indexOf('internal');\n    this.edgeShortcutType = this.edgeTypes.indexOf('shortcut');\n    this.edgeWeakType = this.edgeTypes.indexOf('weak');\n    this.edgeInvisibleType = this.edgeTypes.indexOf('invisible');\n    this.edgePropertyType = this.edgeTypes.indexOf('property');\n\n    const locationFields = meta.location_fields || [];\n\n    this.#locationIndexOffset = locationFields.indexOf('object_index');\n    this.#locationScriptIdOffset = locationFields.indexOf('script_id');\n    this.#locationLineOffset = locationFields.indexOf('line');\n    this.#locationColumnOffset = locationFields.indexOf('column');\n    this.#locationFieldCount = locationFields.length;\n\n    this.nodeCount = this.nodes.length / this.nodeFieldCount;\n    this.#edgeCount = this.containmentEdges.length / this.edgeFieldsCount;\n\n    this.#progress.updateStatus('Building edge indexes');\n    this.firstEdgeIndexes = new Uint32Array(this.nodeCount + 1);\n    this.buildEdgeIndexes();\n    this.#progress.updateStatus('Building retainers');\n    const resultsFromSecondWorker = this.startInitStep1InSecondThread(secondWorker);\n    this.#progress.updateStatus('Propagating DOM state');\n    this.propagateDOMState();\n    this.#progress.updateStatus('Calculating node flags');\n    this.calculateFlags();\n    this.#progress.updateStatus('Building dominated nodes');\n    this.startInitStep2InSecondThread(secondWorker);\n    this.#progress.updateStatus('Calculating shallow sizes');\n    this.calculateShallowSizes();\n    this.#progress.updateStatus('Calculating retained sizes');\n    this.startInitStep3InSecondThread(secondWorker);\n    this.#progress.updateStatus('Calculating distances');\n    this.nodeDistances = new Int32Array(this.nodeCount);\n    this.calculateDistances(/* isForRetainersView=*/ false);\n    this.#progress.updateStatus('Calculating object names');\n    this.calculateObjectNames();\n    this.applyInterfaceDefinitions(this.inferInterfaceDefinitions());\n    this.#progress.updateStatus('Calculating samples');\n    this.buildSamples();\n    this.#progress.updateStatus('Building locations');\n    this.buildLocationMap();\n    this.#progress.updateStatus('Calculating retained sizes');\n    await this.installResultsFromSecondThread(resultsFromSecondWorker);\n    this.#progress.updateStatus('Calculating statistics');\n    this.calculateStatistics();\n\n    if (this.profile.snapshot.trace_function_count) {\n      this.#progress.updateStatus('Building allocation statistics');\n      const nodes = this.nodes;\n      const nodesLength = nodes.length;\n      const nodeFieldCount = this.nodeFieldCount;\n      const node = this.rootNode();\n      const liveObjects: LiveObjects = {};\n      for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n        node.nodeIndex = nodeIndex;\n        const traceNodeId = node.traceNodeId();\n        let stats: {\n          count: number,\n          size: number,\n          ids: number[],\n        } = liveObjects[traceNodeId];\n        if (!stats) {\n          liveObjects[traceNodeId] = stats = {count: 0, size: 0, ids: []};\n        }\n        stats.count++;\n        stats.size += node.selfSize();\n        stats.ids.push(node.id());\n      }\n      this.#allocationProfile = new AllocationProfile(this.profile, liveObjects);\n    }\n\n    this.#progress.updateStatus('Finished processing.');\n  }\n\n  private startInitStep1InSecondThread(secondWorker: MessagePort): Promise<ResultsFromSecondWorker> {\n    const resultsFromSecondWorker = new Promise<ResultsFromSecondWorker>((resolve, reject) => {\n      secondWorker.onmessage = (event: MessageEvent) => {\n        const data = event.data;\n        if (data?.problemReport) {\n          const problemReport: HeapSnapshotProblemReport = data.problemReport;\n          console.warn(formatProblemReport(this, problemReport));\n        } else if (data?.resultsFromSecondWorker) {\n          const resultsFromSecondWorker: ResultsFromSecondWorker = data.resultsFromSecondWorker;\n          resolve(resultsFromSecondWorker);\n        } else if (data?.error) {\n          reject(data.error);\n        }\n      };\n    });\n    const edgeCount = this.#edgeCount;\n    const {containmentEdges, edgeToNodeOffset, edgeFieldsCount, nodeFieldCount} = this;\n    const edgeToNodeOrdinals = new Uint32Array(edgeCount);\n    for (let edgeOrdinal = 0; edgeOrdinal < edgeCount; ++edgeOrdinal) {\n      const toNodeIndex = containmentEdges.getValue(edgeOrdinal * edgeFieldsCount + edgeToNodeOffset);\n      if (toNodeIndex % nodeFieldCount) {\n        throw new Error('Invalid toNodeIndex ' + toNodeIndex);\n      }\n      edgeToNodeOrdinals[edgeOrdinal] = toNodeIndex / nodeFieldCount;\n    }\n    const args: SecondaryInitArgumentsStep1 = {\n      edgeToNodeOrdinals,\n      firstEdgeIndexes: this.firstEdgeIndexes,\n      nodeCount: this.nodeCount,\n      edgeFieldsCount: this.edgeFieldsCount,\n      nodeFieldCount: this.nodeFieldCount,\n    };\n    // Note that firstEdgeIndexes is not transferred; each thread needs its own copy.\n    secondWorker.postMessage({step: 1, args}, [edgeToNodeOrdinals.buffer]);\n    return resultsFromSecondWorker;\n  }\n\n  private startInitStep2InSecondThread(secondWorker: MessagePort): void {\n    const rootNodeOrdinal = this.rootNodeIndexInternal / this.nodeFieldCount;\n    const essentialEdges = this.initEssentialEdges();\n    const args: SecondaryInitArgumentsStep2 = {rootNodeOrdinal, essentialEdgesBuffer: essentialEdges.buffer};\n    secondWorker.postMessage({step: 2, args}, [essentialEdges.buffer]);\n  }\n\n  private startInitStep3InSecondThread(secondWorker: MessagePort): void {\n    const {nodes, nodeFieldCount, nodeSelfSizeOffset, nodeCount} = this;\n    const nodeSelfSizes = new Uint32Array(nodeCount);\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      nodeSelfSizes[nodeOrdinal] = nodes.getValue(nodeOrdinal * nodeFieldCount + nodeSelfSizeOffset);\n    }\n    const args: SecondaryInitArgumentsStep3 = {nodeSelfSizes};\n    secondWorker.postMessage({step: 3, args}, [nodeSelfSizes.buffer]);\n  }\n\n  private async installResultsFromSecondThread(resultsFromSecondWorker: Promise<ResultsFromSecondWorker>):\n      Promise<void> {\n    const results = await resultsFromSecondWorker;\n    this.dominatedNodes = results.dominatedNodes;\n    this.dominatorsTree = results.dominatorsTree;\n    this.firstDominatedNodeIndex = results.firstDominatedNodeIndex;\n    this.firstRetainerIndex = results.firstRetainerIndex;\n    this.retainedSizes = results.retainedSizes;\n    this.retainingEdges = results.retainingEdges;\n    this.retainingNodes = results.retainingNodes;\n  }\n\n  private buildEdgeIndexes(): void {\n    const nodes = this.nodes;\n    const nodeCount = this.nodeCount;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const nodeFieldCount = this.nodeFieldCount;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const nodeEdgeCountOffset = this.#nodeEdgeCountOffset;\n    firstEdgeIndexes[nodeCount] = this.containmentEdges.length;\n    for (let nodeOrdinal = 0, edgeIndex = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      firstEdgeIndexes[nodeOrdinal] = edgeIndex;\n      edgeIndex += nodes.getValue(nodeOrdinal * nodeFieldCount + nodeEdgeCountOffset) * edgeFieldsCount;\n    }\n  }\n\n  static buildRetainers(inputs: ArgumentsToBuildRetainers): Retainers {\n    const {edgeToNodeOrdinals, firstEdgeIndexes, nodeCount, edgeFieldsCount, nodeFieldCount} = inputs;\n    const edgeCount = edgeToNodeOrdinals.length;\n    const retainingNodes = new Uint32Array(edgeCount);\n    const retainingEdges = new Uint32Array(edgeCount);\n    const firstRetainerIndex = new Uint32Array(nodeCount + 1);\n\n    for (let edgeOrdinal = 0; edgeOrdinal < edgeCount; ++edgeOrdinal) {\n      const toNodeOrdinal = edgeToNodeOrdinals[edgeOrdinal];\n      ++firstRetainerIndex[toNodeOrdinal];\n    }\n    for (let i = 0, firstUnusedRetainerSlot = 0; i < nodeCount; i++) {\n      const retainersCount = firstRetainerIndex[i];\n      firstRetainerIndex[i] = firstUnusedRetainerSlot;\n      retainingNodes[firstUnusedRetainerSlot] = retainersCount;\n      firstUnusedRetainerSlot += retainersCount;\n    }\n    firstRetainerIndex[nodeCount] = retainingNodes.length;\n\n    let nextNodeFirstEdgeIndex: number = firstEdgeIndexes[0];\n    for (let srcNodeOrdinal = 0; srcNodeOrdinal < nodeCount; ++srcNodeOrdinal) {\n      const firstEdgeIndex = nextNodeFirstEdgeIndex;\n      nextNodeFirstEdgeIndex = firstEdgeIndexes[srcNodeOrdinal + 1];\n      const srcNodeIndex = srcNodeOrdinal * nodeFieldCount;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < nextNodeFirstEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const toNodeOrdinal = edgeToNodeOrdinals[edgeIndex / edgeFieldsCount];\n        const firstRetainerSlotIndex = firstRetainerIndex[toNodeOrdinal];\n        const nextUnusedRetainerSlotIndex = firstRetainerSlotIndex + (--retainingNodes[firstRetainerSlotIndex]);\n        retainingNodes[nextUnusedRetainerSlotIndex] = srcNodeIndex;\n        retainingEdges[nextUnusedRetainerSlotIndex] = edgeIndex;\n      }\n    }\n\n    return {\n      retainingNodes,\n      retainingEdges,\n      firstRetainerIndex,\n    };\n  }\n\n  abstract createNode(_nodeIndex?: number): HeapSnapshotNode;\n  abstract createEdge(_edgeIndex: number): JSHeapSnapshotEdge;\n  abstract createRetainingEdge(_retainerIndex: number): JSHeapSnapshotRetainerEdge;\n\n  private allNodes(): HeapSnapshotNodeIterator {\n    return new HeapSnapshotNodeIterator(this.rootNode());\n  }\n\n  rootNode(): HeapSnapshotNode {\n    return this.createNode(this.rootNodeIndexInternal);\n  }\n\n  get rootNodeIndex(): number {\n    return this.rootNodeIndexInternal;\n  }\n\n  get totalSize(): number {\n    return this.rootNode().retainedSize() + (this.profile.snapshot.extra_native_bytes ?? 0);\n  }\n\n  private createFilter(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      ((arg0: HeapSnapshotNode) => boolean)|undefined {\n    const {minNodeId, maxNodeId, allocationNodeId, filterName} = nodeFilter;\n    let filter;\n    if (typeof allocationNodeId === 'number') {\n      filter = this.createAllocationStackFilter(allocationNodeId);\n      if (!filter) {\n        throw new Error('Unable to create filter');\n      }\n      // @ts-expect-error key can be added as a static property\n      filter.key = 'AllocationNodeId: ' + allocationNodeId;\n    } else if (typeof minNodeId === 'number' && typeof maxNodeId === 'number') {\n      filter = this.createNodeIdFilter(minNodeId, maxNodeId);\n      // @ts-expect-error key can be added as a static property\n      filter.key = 'NodeIdRange: ' + minNodeId + '..' + maxNodeId;\n    } else if (filterName !== undefined) {\n      filter = this.createNamedFilter(filterName);\n      // @ts-expect-error key can be added as a static property\n      filter.key = 'NamedFilter: ' + filterName;\n    }\n    return filter;\n  }\n\n  search(\n      searchConfig: HeapSnapshotModel.HeapSnapshotModel.SearchConfig,\n      nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter): number[] {\n    const query = searchConfig.query;\n\n    function filterString(matchedStringIndexes: Set<number>, string: string, index: number): Set<number> {\n      if (string.indexOf(query) !== -1) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const regexp =\n        searchConfig.isRegex ? new RegExp(query) : Platform.StringUtilities.createPlainTextSearchRegex(query, 'i');\n\n    function filterRegexp(matchedStringIndexes: Set<number>, string: string, index: number): Set<number> {\n      if (regexp.test(string)) {\n        matchedStringIndexes.add(index);\n      }\n      return matchedStringIndexes;\n    }\n\n    const useRegExp = searchConfig.isRegex || !searchConfig.caseSensitive;\n    const stringFilter = useRegExp ? filterRegexp : filterString;\n    const stringIndexes = this.strings.reduce(stringFilter, new Set());\n\n    const filter = this.createFilter(nodeFilter);\n    const nodeIds = [];\n    const nodesLength = this.nodes.length;\n    const nodes = this.nodes;\n    const nodeNameOffset = this.nodeNameOffset;\n    const nodeIdOffset = this.nodeIdOffset;\n    const nodeFieldCount = this.nodeFieldCount;\n    const node = this.rootNode();\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      if (node.selfSize() === 0) {\n        // Nodes with size zero are omitted in the data grid, so avoid returning\n        // search results that can't be navigated to.\n        continue;\n      }\n      const name = node.name();\n      if (name === node.rawName()) {\n        // If the string displayed to the user matches the raw name from the\n        // snapshot, then we can use the Set computed above. This avoids\n        // repeated work when multiple nodes have the same name.\n        if (stringIndexes.has(nodes.getValue(nodeIndex + nodeNameOffset))) {\n          nodeIds.push(nodes.getValue(nodeIndex + nodeIdOffset));\n        }\n        // If the node is displaying a customized name, then we must perform the\n        // full string search within that name here.\n      } else if (useRegExp ? regexp.test(name) : (name.indexOf(query) !== -1)) {\n        nodeIds.push(nodes.getValue(nodeIndex + nodeIdOffset));\n      }\n    }\n    return nodeIds;\n  }\n\n  aggregatesWithFilter(nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      Record<string, HeapSnapshotModel.HeapSnapshotModel.Aggregate> {\n    const filter = this.createFilter(nodeFilter);\n    // @ts-expect-error key is added in createFilter\n    const key = filter ? filter.key : 'allObjects';\n    return this.getAggregatesByClassKey(false, key, filter);\n  }\n\n  private createNodeIdFilter(minNodeId: number, maxNodeId: number): (arg0: HeapSnapshotNode) => boolean {\n    function nodeIdFilter(node: HeapSnapshotNode): boolean {\n      const id = node.id();\n      return id > minNodeId && id <= maxNodeId;\n    }\n    return nodeIdFilter;\n  }\n\n  private createAllocationStackFilter(bottomUpAllocationNodeId: number):\n      ((arg0: HeapSnapshotNode) => boolean)|undefined {\n    if (!this.#allocationProfile) {\n      throw new Error('No Allocation Profile provided');\n    }\n\n    const traceIds = this.#allocationProfile.traceIds(bottomUpAllocationNodeId);\n    if (!traceIds.length) {\n      return undefined;\n    }\n\n    const set: Record<number, boolean> = {};\n    for (let i = 0; i < traceIds.length; i++) {\n      set[traceIds[i]] = true;\n    }\n    function traceIdFilter(node: HeapSnapshotNode): boolean {\n      return Boolean(set[node.traceNodeId()]);\n    }\n    return traceIdFilter;\n  }\n\n  private createNamedFilter(filterName: string): (node: HeapSnapshotNode) => boolean {\n    // Allocate an array with a single bit per node, which can be used by each\n    // specific filter implemented below.\n    const bitmap = Platform.TypedArrayUtilities.createBitVector(this.nodeCount);\n    const getBit = (node: HeapSnapshotNode): boolean => {\n      const ordinal = node.nodeIndex / this.nodeFieldCount;\n      return bitmap.getBit(ordinal);\n    };\n\n    // Traverses the graph in breadth-first order with the given filter, and\n    // sets the bit in `bitmap` for every visited node.\n    const traverse = (filter: (node: HeapSnapshotNode, edge: HeapSnapshotEdge) => boolean): void => {\n      const distances = new Int32Array(this.nodeCount);\n      for (let i = 0; i < this.nodeCount; ++i) {\n        distances[i] = this.#noDistance;\n      }\n      const nodesToVisit = new Uint32Array(this.nodeCount);\n      distances[this.rootNode().ordinal()] = 0;\n      nodesToVisit[0] = this.rootNode().nodeIndex;\n      const nodesToVisitLength = 1;\n      this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n      for (let i = 0; i < this.nodeCount; ++i) {\n        if (distances[i] !== this.#noDistance) {\n          bitmap.setBit(i);\n        }\n      }\n    };\n\n    const markUnreachableNodes = (): void => {\n      for (let i = 0; i < this.nodeCount; ++i) {\n        if (this.nodeDistances[i] === this.#noDistance) {\n          bitmap.setBit(i);\n        }\n      }\n    };\n\n    switch (filterName) {\n      case 'objectsRetainedByDetachedDomNodes':\n        // Traverse the graph, avoiding detached nodes.\n        traverse((_node: HeapSnapshotNode, edge: HeapSnapshotEdge) => {\n          return edge.node().detachedness() !== DOMLinkState.DETACHED;\n        });\n        markUnreachableNodes();\n        return (node: HeapSnapshotNode) => !getBit(node);\n      case 'objectsRetainedByConsole':\n        // Traverse the graph, avoiding edges that represent globals owned by\n        // the DevTools console.\n        traverse((node: HeapSnapshotNode, edge: HeapSnapshotEdge) => {\n          return !(node.isSynthetic() && edge.hasStringName() && edge.name().endsWith(' / DevTools console'));\n        });\n        markUnreachableNodes();\n        return (node: HeapSnapshotNode) => !getBit(node);\n      case 'duplicatedStrings': {\n        const stringToNodeIndexMap = new Map<string, number>();\n        const node = this.createNode(0);\n        for (let i = 0; i < this.nodeCount; ++i) {\n          node.nodeIndex = i * this.nodeFieldCount;\n          const rawType = node.rawType();\n          if (rawType === this.nodeStringType || rawType === this.nodeConsStringType) {\n            // Check whether the cons string is already \"flattened\", meaning\n            // that one of its two parts is the empty string. If so, we should\n            // skip it. We don't help anyone by reporting a flattened cons\n            // string as a duplicate with its own content, since V8 controls\n            // that behavior internally.\n            if (node.isFlatConsString()) {\n              continue;\n            }\n            const name = node.name();\n            const alreadyVisitedNodeIndex = stringToNodeIndexMap.get(name);\n            if (alreadyVisitedNodeIndex === undefined) {\n              stringToNodeIndexMap.set(name, node.nodeIndex);\n            } else {\n              bitmap.setBit(alreadyVisitedNodeIndex / this.nodeFieldCount);\n              bitmap.setBit(node.nodeIndex / this.nodeFieldCount);\n            }\n          }\n        }\n        return getBit;\n      }\n    }\n    throw new Error('Invalid filter name');\n  }\n\n  getAggregatesByClassKey(sortedIndexes: boolean, key?: string, filter?: ((arg0: HeapSnapshotNode) => boolean)):\n      Record<string, HeapSnapshotModel.HeapSnapshotModel.Aggregate> {\n    let aggregates: Record<string, HeapSnapshotModel.HeapSnapshotModel.Aggregate>;\n    if (key && this.#aggregates[key]) {\n      aggregates = this.#aggregates[key];\n    } else {\n      const aggregatesMap = this.buildAggregates(filter);\n      this.calculateClassesRetainedSize(aggregatesMap, filter);\n\n      // In the two previous steps, we used class keys that were simple and\n      // could be produced quickly. For many objects, this meant using the index\n      // of the string containing its class name. However, string indices are\n      // not consistent across snapshots, and this aggregate data might end up\n      // being used in a comparison, so here we convert to a more durable format\n      // for class keys.\n      aggregates = Object.create(null);\n      for (const [classKey, aggregate] of aggregatesMap.entries()) {\n        const newKey = this.classKeyFromClassKeyInternal(classKey);\n        aggregates[newKey] = aggregate;\n      }\n      if (key) {\n        this.#aggregates[key] = aggregates;\n      }\n    }\n\n    if (sortedIndexes && (!key || !this.#aggregatesSortedFlags[key])) {\n      this.sortAggregateIndexes(aggregates);\n      if (key) {\n        this.#aggregatesSortedFlags[key] = sortedIndexes;\n      }\n    }\n\n    return aggregates as Record<string, HeapSnapshotModel.HeapSnapshotModel.Aggregate>;\n  }\n\n  allocationTracesTops(): HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode[] {\n    return this.#allocationProfile.serializeTraceTops();\n  }\n\n  allocationNodeCallers(nodeId: number): HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers {\n    return this.#allocationProfile.serializeCallers(nodeId);\n  }\n\n  allocationStack(nodeIndex: number): HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame[]|null {\n    const node = this.createNode(nodeIndex);\n    const allocationNodeId = node.traceNodeId();\n    if (!allocationNodeId) {\n      return null;\n    }\n    return this.#allocationProfile.serializeAllocationStack(allocationNodeId);\n  }\n\n  aggregatesForDiff(interfaceDefinitions: string):\n      Record<string, HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff> {\n    if (this.#aggregatesForDiffInternal?.interfaceDefinitions === interfaceDefinitions) {\n      return this.#aggregatesForDiffInternal.aggregates;\n    }\n\n    // Temporarily apply the interface definitions from the other snapshot.\n    const originalInterfaceDefinitions = this.#interfaceDefinitions;\n    this.applyInterfaceDefinitions(JSON.parse(interfaceDefinitions) as InterfaceDefinition[]);\n    const aggregates = this.getAggregatesByClassKey(true, 'allObjects');\n    this.applyInterfaceDefinitions(originalInterfaceDefinitions ?? []);\n    const result: Record<string, HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff> = {};\n\n    const node = this.createNode();\n    for (const classKey in aggregates) {\n      const aggregate = aggregates[classKey];\n      const indexes = aggregate.idxs;\n      const ids = new Array(indexes.length);\n      const selfSizes = new Array(indexes.length);\n      for (let i = 0; i < indexes.length; i++) {\n        node.nodeIndex = indexes[i];\n        ids[i] = node.id();\n        selfSizes[i] = node.selfSize();\n      }\n\n      result[classKey] = {name: node.className(), indexes, ids, selfSizes};\n    }\n\n    this.#aggregatesForDiffInternal = {interfaceDefinitions, aggregates: result};\n    return result;\n  }\n\n  isUserRoot(_node: HeapSnapshotNode): boolean {\n    return true;\n  }\n\n  calculateShallowSizes(): void {\n  }\n\n  calculateDistances(\n      isForRetainersView: boolean, filter?: ((arg0: HeapSnapshotNode, arg1: HeapSnapshotEdge) => boolean)): void {\n    const nodeCount = this.nodeCount;\n\n    if (isForRetainersView) {\n      const originalFilter = filter;\n      filter = (node: HeapSnapshotNode, edge: HeapSnapshotEdge) => {\n        return !this.#ignoredNodesInRetainersView.has(edge.nodeIndex()) &&\n            (!originalFilter || originalFilter(node, edge));\n      };\n      if (this.#nodeDistancesForRetainersView === undefined) {\n        this.#nodeDistancesForRetainersView = new Int32Array(nodeCount);\n      }\n    }\n\n    const distances = isForRetainersView ? (this.#nodeDistancesForRetainersView as Int32Array) : this.nodeDistances;\n    const noDistance = this.#noDistance;\n    for (let i = 0; i < nodeCount; ++i) {\n      distances[i] = noDistance;\n    }\n\n    const nodesToVisit = new Uint32Array(this.nodeCount);\n    let nodesToVisitLength = 0;\n\n    // BFS for user root objects.\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      const node = iter.edge.node();\n      if (this.isUserRoot(node)) {\n        distances[node.ordinal()] = 1;\n        nodesToVisit[nodesToVisitLength++] = node.nodeIndex;\n      }\n    }\n    this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n\n    // BFS for objects not reached from user roots.\n    distances[this.rootNode().ordinal()] =\n        nodesToVisitLength > 0 ? HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance : 0;\n    nodesToVisit[0] = this.rootNode().nodeIndex;\n    nodesToVisitLength = 1;\n    this.bfs(nodesToVisit, nodesToVisitLength, distances, filter);\n  }\n\n  private bfs(\n      nodesToVisit: Uint32Array, nodesToVisitLength: number, distances: Int32Array,\n      filter?: ((arg0: HeapSnapshotNode, arg1: HeapSnapshotEdge) => boolean)): void {\n    // Preload fields into local variables for better performance.\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const nodeFieldCount = this.nodeFieldCount;\n    const containmentEdges = this.containmentEdges;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const nodeCount = this.nodeCount;\n    const edgeWeakType = this.edgeWeakType;\n    const noDistance = this.#noDistance;\n\n    let index = 0;\n    const edge = this.createEdge(0);\n    const node = this.createNode(0);\n    while (index < nodesToVisitLength) {\n      const nodeIndex = nodesToVisit[index++];  // shift generates too much garbage.\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = distances[nodeOrdinal] + 1;\n      const firstEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const edgesEnd = firstEdgeIndexes[nodeOrdinal + 1];\n      node.nodeIndex = nodeIndex;\n      for (let edgeIndex = firstEdgeIndex; edgeIndex < edgesEnd; edgeIndex += edgeFieldsCount) {\n        const edgeType = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n        if (edgeType === edgeWeakType) {\n          continue;\n        }\n        const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (distances[childNodeOrdinal] !== noDistance) {\n          continue;\n        }\n        edge.edgeIndex = edgeIndex;\n        if (filter && !filter(node, edge)) {\n          continue;\n        }\n        distances[childNodeOrdinal] = distance;\n        nodesToVisit[nodesToVisitLength++] = childNodeIndex;\n      }\n    }\n    if (nodesToVisitLength > nodeCount) {\n      throw new Error(\n          'BFS failed. Nodes to visit (' + nodesToVisitLength + ') is more than nodes count (' + nodeCount + ')');\n    }\n  }\n\n  private buildAggregates(filter?: ((arg0: HeapSnapshotNode) => boolean)): Map<string|number, AggregatedInfo> {\n    const aggregates = new Map<string|number, AggregatedInfo>();\n\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const selfSizeOffset = this.nodeSelfSizeOffset;\n    const node = this.rootNode();\n    const nodeDistances = this.nodeDistances;\n\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      if (filter && !filter(node)) {\n        continue;\n      }\n      const selfSize = nodes.getValue(nodeIndex + selfSizeOffset);\n      if (!selfSize) {\n        continue;\n      }\n      const classKey = node.classKeyInternal();\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const distance = nodeDistances[nodeOrdinal];\n      let aggregate = aggregates.get(classKey);\n      if (!aggregate) {\n        aggregate = {\n          count: 1,\n          distance,\n          self: selfSize,\n          maxRet: 0,\n          name: node.className(),\n          idxs: [nodeIndex],\n        };\n        aggregates.set(classKey, aggregate);\n      } else {\n        aggregate.distance = Math.min(aggregate.distance, distance);\n        ++aggregate.count;\n        aggregate.self += selfSize;\n        aggregate.idxs.push(nodeIndex);\n      }\n    }\n\n    // Shave off provisionally allocated space.\n    for (const aggregate of aggregates.values()) {\n      aggregate.idxs = aggregate.idxs.slice();\n    }\n\n    return aggregates;\n  }\n\n  private calculateClassesRetainedSize(\n      aggregates: Map<string|number, AggregatedInfo>, filter?: ((arg0: HeapSnapshotNode) => boolean)): void {\n    const rootNodeIndex = this.rootNodeIndexInternal;\n    const node = this.createNode(rootNodeIndex);\n    const list = [rootNodeIndex];\n    const sizes = [-1];\n    const classKeys: Array<string|number> = [];\n\n    const seenClassKeys = new Map<string|number, boolean>();\n    const nodeFieldCount = this.nodeFieldCount;\n    const dominatedNodes = this.dominatedNodes;\n    const firstDominatedNodeIndex = this.firstDominatedNodeIndex;\n\n    while (list.length) {\n      const nodeIndex = (list.pop() as number);\n      node.nodeIndex = nodeIndex;\n      let classKey = node.classKeyInternal();\n      const seen = Boolean(seenClassKeys.get(classKey));\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const dominatedIndexFrom = firstDominatedNodeIndex[nodeOrdinal];\n      const dominatedIndexTo = firstDominatedNodeIndex[nodeOrdinal + 1];\n\n      if (!seen && (!filter || filter(node)) && node.selfSize()) {\n        (aggregates.get(classKey) as AggregatedInfo).maxRet += node.retainedSize();\n        if (dominatedIndexFrom !== dominatedIndexTo) {\n          seenClassKeys.set(classKey, true);\n          sizes.push(list.length);\n          classKeys.push(classKey);\n        }\n      }\n      for (let i = dominatedIndexFrom; i < dominatedIndexTo; i++) {\n        list.push(dominatedNodes[i]);\n      }\n\n      const l = list.length;\n      while (sizes[sizes.length - 1] === l) {\n        sizes.pop();\n        classKey = (classKeys.pop() as string);\n        seenClassKeys.set(classKey, false);\n      }\n    }\n  }\n\n  private sortAggregateIndexes(aggregates: Record<string, AggregatedInfo>): void {\n    const nodeA = this.createNode();\n    const nodeB = this.createNode();\n\n    for (const clss in aggregates) {\n      aggregates[clss].idxs.sort((idxA, idxB) => {\n        nodeA.nodeIndex = idxA;\n        nodeB.nodeIndex = idxB;\n        return nodeA.id() < nodeB.id() ? -1 : 1;\n      });\n    }\n  }\n\n  tryParseWeakMapEdgeName(edgeNameIndex: number): {duplicatedPart: string, tableId: string}|undefined {\n    const previousResult = this.#edgeNamesThatAreNotWeakMaps.getBit(edgeNameIndex);\n    if (previousResult) {\n      return undefined;\n    }\n    const edgeName = this.strings[edgeNameIndex];\n    const ephemeronNameRegex =\n        /^\\d+(?<duplicatedPart> \\/ part of key \\(.*? @\\d+\\) -> value \\(.*? @\\d+\\) pair in WeakMap \\(table @(?<tableId>\\d+)\\))$/;\n    const match = edgeName.match(ephemeronNameRegex);\n    if (!match) {\n      this.#edgeNamesThatAreNotWeakMaps.setBit(edgeNameIndex);\n      return undefined;\n    }\n    return match.groups as {duplicatedPart: string, tableId: string};\n  }\n\n  private computeIsEssentialEdge(\n      nodeIndex: number, edgeIndex: number, userObjectsMapAndFlag: {map: Uint8Array, flag: number}|null): boolean {\n    const edgeType = this.containmentEdges.getValue(edgeIndex + this.edgeTypeOffset);\n\n    // Values in WeakMaps are retained by the key and table together. Removing\n    // either the key or the table would be sufficient to remove the edge from\n    // the other one, so we needn't use both of those edges when computing\n    // dominators. We've found that the edge from the key generally produces\n    // more useful results, so here we skip the edge from the table.\n    if (edgeType === this.edgeInternalType) {\n      const edgeNameIndex = this.containmentEdges.getValue(edgeIndex + this.edgeNameOffset);\n      const match = this.tryParseWeakMapEdgeName(edgeNameIndex);\n      if (match) {\n        const nodeId = this.nodes.getValue(nodeIndex + this.nodeIdOffset);\n        if (nodeId === parseInt(match.tableId, 10)) {\n          return false;\n        }\n      }\n    }\n\n    // Weak edges never retain anything.\n    if (edgeType === this.edgeWeakType) {\n      return false;\n    }\n\n    const childNodeIndex = this.containmentEdges.getValue(edgeIndex + this.edgeToNodeOffset);\n    // Ignore self edges.\n    if (nodeIndex === childNodeIndex) {\n      return false;\n    }\n\n    if (nodeIndex !== this.rootNodeIndex) {\n      // Shortcuts at the root node have special meaning of marking user global objects.\n      if (edgeType === this.edgeShortcutType) {\n        return false;\n      }\n\n      const flags = userObjectsMapAndFlag ? userObjectsMapAndFlag.map : null;\n      const userObjectFlag = userObjectsMapAndFlag ? userObjectsMapAndFlag.flag : 0;\n      const nodeOrdinal = nodeIndex / this.nodeFieldCount;\n      const childNodeOrdinal = childNodeIndex / this.nodeFieldCount;\n      const nodeFlag = !flags || (flags[nodeOrdinal] & userObjectFlag);\n      const childNodeFlag = !flags || (flags[childNodeOrdinal] & userObjectFlag);\n      // We are skipping the edges from non-page-owned nodes to page-owned nodes.\n      // Otherwise the dominators for the objects that also were retained by debugger would be affected.\n      if (childNodeFlag && !nodeFlag) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  // Returns a bitmap indicating whether each edge should be considered when building the dominator tree.\n  private initEssentialEdges(): Platform.TypedArrayUtilities.BitVector {\n    const essentialEdges = Platform.TypedArrayUtilities.createBitVector(this.#edgeCount);\n    const {nodes, nodeFieldCount, edgeFieldsCount} = this;\n    const userObjectsMapAndFlag = this.userObjectsMapAndFlag();\n    const endNodeIndex = nodes.length;\n    const node = this.createNode(0);\n    for (let nodeIndex = 0; nodeIndex < endNodeIndex; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n      const edgeIndexesEnd = node.edgeIndexesEnd();\n      for (let edgeIndex = node.edgeIndexesStart(); edgeIndex < edgeIndexesEnd; edgeIndex += edgeFieldsCount) {\n        if (this.computeIsEssentialEdge(nodeIndex, edgeIndex, userObjectsMapAndFlag)) {\n          essentialEdges.setBit(edgeIndex / edgeFieldsCount);\n        }\n      }\n    }\n    return essentialEdges;\n  }\n\n  static hasOnlyWeakRetainers(inputs: ArgumentsToComputeDominatorsAndRetainedSizes, nodeOrdinal: number): boolean {\n    const {retainingEdges, edgeFieldsCount, firstRetainerIndex, essentialEdges} = inputs;\n    const beginRetainerIndex = firstRetainerIndex[nodeOrdinal];\n    const endRetainerIndex = firstRetainerIndex[nodeOrdinal + 1];\n    for (let retainerIndex = beginRetainerIndex; retainerIndex < endRetainerIndex; ++retainerIndex) {\n      const retainerEdgeIndex = retainingEdges[retainerIndex];\n      if (essentialEdges.getBit(retainerEdgeIndex / edgeFieldsCount)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // The algorithm for building the dominator tree is from the paper:\n  // Thomas Lengauer and Robert Endre Tarjan. 1979. A fast algorithm for finding dominators in a flowgraph.\n  // ACM Trans. Program. Lang. Syst. 1, 1 (July 1979), 121141. https://doi.org/10.1145/357062.357071\n  static async calculateDominatorsAndRetainedSizes(inputs: ArgumentsToComputeDominatorsAndRetainedSizes):\n      Promise<DominatorsAndRetainedSizes> {\n    // Preload fields into local variables for better performance.\n    const {\n      nodeCount,\n      firstEdgeIndexes,\n      edgeFieldsCount,\n      nodeFieldCount,\n      firstRetainerIndex,\n      retainingEdges,\n      retainingNodes,\n      edgeToNodeOrdinals,\n      rootNodeOrdinal,\n      essentialEdges,\n      nodeSelfSizesPromise,\n      port\n    } = inputs;\n    function isEssentialEdge(edgeIndex: number): boolean {\n      return essentialEdges.getBit(edgeIndex / edgeFieldsCount);\n    }\n\n    // The Lengauer-Tarjan algorithm expects vectors to be numbered from 1 to n\n    // and uses 0 as an invalid value, so use 1-indexing for all the arrays.\n    // Convert between ordinals and vertex numbers by adding/subtracting 1.\n    const arrayLength = nodeCount + 1;\n    const parent = new Uint32Array(arrayLength);\n    const ancestor = new Uint32Array(arrayLength);\n    const vertex = new Uint32Array(arrayLength);\n    const label = new Uint32Array(arrayLength);\n    const semi = new Uint32Array(arrayLength);\n    const bucket = new Array<Set<number>>(arrayLength);\n    let n = 0;\n\n    // Iterative DFS since the recursive version can cause stack overflows.\n    // Use an array to keep track of the next edge index to be examined for each node.\n    const nextEdgeIndex = new Uint32Array(arrayLength);\n    const dfs = (root: number): void => {\n      const rootOrdinal = root - 1;\n      nextEdgeIndex[rootOrdinal] = firstEdgeIndexes[rootOrdinal];\n      let v = root;\n      while (v !== 0) {\n        // First process v if not done already.\n        if (semi[v] === 0) {\n          semi[v] = ++n;\n          vertex[n] = label[v] = v;\n        }\n\n        // The next node to process is the first unprocessed successor w of v,\n        // or parent[v] if all of v's successors have already been processed.\n        let vNext = parent[v];\n        const vOrdinal = v - 1;\n        for (; nextEdgeIndex[vOrdinal] < firstEdgeIndexes[vOrdinal + 1]; nextEdgeIndex[vOrdinal] += edgeFieldsCount) {\n          const edgeIndex = nextEdgeIndex[vOrdinal];\n          if (!isEssentialEdge(edgeIndex)) {\n            continue;\n          }\n          const wOrdinal = edgeToNodeOrdinals[edgeIndex / edgeFieldsCount];\n          const w = wOrdinal + 1;\n          if (semi[w] === 0) {\n            parent[w] = v;\n            nextEdgeIndex[wOrdinal] = firstEdgeIndexes[wOrdinal];\n            vNext = w;\n            break;\n          }\n        }\n        v = vNext;\n      }\n    };\n\n    // Iterative version since the recursive version can cause stack overflows.\n    // Preallocate a stack since compress() is called several times.\n    // The stack cannot grow larger than the number of nodes since we walk up\n    // the tree represented by the ancestor array.\n    const compressionStack = new Uint32Array(arrayLength);\n    const compress = (v: number): void => {\n      let stackPointer = 0;\n      while (ancestor[ancestor[v]] !== 0) {\n        compressionStack[++stackPointer] = v;\n        v = ancestor[v];\n      }\n      while (stackPointer > 0) {\n        const w = compressionStack[stackPointer--];\n        if (semi[label[ancestor[w]]] < semi[label[w]]) {\n          label[w] = label[ancestor[w]];\n        }\n        ancestor[w] = ancestor[ancestor[w]];\n      }\n    };\n\n    // Simple versions of eval and link from the paper.\n    const evaluate = (v: number): number => {\n      if (ancestor[v] === 0) {\n        return v;\n      }\n      compress(v);\n      return label[v];\n    };\n\n    const link = (v: number, w: number): void => {\n      ancestor[w] = v;\n    };\n\n    // Algorithm begins here. The variable names are as per the paper.\n    const r = rootNodeOrdinal + 1;\n    n = 0;\n    const dom = new Uint32Array(arrayLength);\n\n    // First perform DFS from the root.\n    dfs(r);\n\n    // Then perform DFS from orphan nodes (ones with only weak retainers) if any.\n    if (n < nodeCount) {\n      const errors: HeapSnapshotProblemReport =\n          [`Heap snapshot: ${nodeCount - n} nodes are unreachable from the root.`];\n      appendToProblemReport(errors, 'The following nodes have only weak retainers:');\n      for (let v = 1; v <= nodeCount; v++) {\n        const vOrdinal = v - 1;\n        if (semi[v] === 0 && HeapSnapshot.hasOnlyWeakRetainers(inputs, vOrdinal)) {\n          appendToProblemReport(errors, vOrdinal * nodeFieldCount);\n          parent[v] = r;\n          dfs(v);\n        }\n      }\n      reportProblemToPrimaryWorker(errors, port);\n    }\n\n    // If there are unreachable nodes still, visit them individually from the root.\n    // This can happen when there is a clique of nodes retained by one another.\n    if (n < nodeCount) {\n      const errors: HeapSnapshotProblemReport = [`Heap snapshot: Still found ${nodeCount - n} unreachable nodes:`];\n      for (let v = 1; v <= nodeCount; v++) {\n        if (semi[v] === 0) {\n          const vOrdinal = v - 1;\n          appendToProblemReport(errors, vOrdinal * nodeFieldCount);\n          parent[v] = r;\n          semi[v] = ++n;\n          vertex[n] = label[v] = v;\n        }\n      }\n      reportProblemToPrimaryWorker(errors, port);\n    }\n\n    // Main loop. Process the vertices in decreasing order by DFS number.\n    for (let i = n; i >= 2; --i) {\n      const w = vertex[i];\n      // Iterate over all predecessors v of w.\n      const wOrdinal = w - 1;\n      let isOrphanNode = true;\n      for (let retainerIndex = firstRetainerIndex[wOrdinal]; retainerIndex < firstRetainerIndex[wOrdinal + 1];\n           retainerIndex++) {\n        if (!isEssentialEdge(retainingEdges[retainerIndex])) {\n          continue;\n        }\n        isOrphanNode = false;\n        const vOrdinal = retainingNodes[retainerIndex] / nodeFieldCount;\n        const v = vOrdinal + 1;\n        const u = evaluate(v);\n        if (semi[u] < semi[w]) {\n          semi[w] = semi[u];\n        }\n      }\n      if (isOrphanNode) {\n        // We treat orphan nodes as having a single predecessor - the root.\n        // semi[r] is always less than any semi[w] so set it unconditionally.\n        semi[w] = semi[r];\n      }\n\n      if (bucket[vertex[semi[w]]] === undefined) {\n        bucket[vertex[semi[w]]] = new Set<number>();\n      }\n      bucket[vertex[semi[w]]].add(w);\n      link(parent[w], w);\n\n      // Process all vertices v in bucket(parent(w)).\n      if (bucket[parent[w]] !== undefined) {\n        for (const v of bucket[parent[w]]) {\n          const u = evaluate(v);\n          dom[v] = semi[u] < semi[v] ? u : parent[w];\n        }\n        bucket[parent[w]].clear();\n      }\n    }\n\n    // Final step. Fill in the immediate dominators not explicitly computed above.\n    // Unlike the paper, we consider the root to be its own dominator and\n    // set dom[0] to r to propagate the root as the dominator of unreachable nodes.\n    dom[0] = dom[r] = r;\n    for (let i = 2; i <= n; i++) {\n      const w = vertex[i];\n      if (dom[w] !== vertex[semi[w]]) {\n        dom[w] = dom[dom[w]];\n      }\n    }\n    // Algorithm ends here.\n\n    // Transform the dominators into an ordinal-indexed array and populate the self sizes.\n    const dominatorsTree = new Uint32Array(nodeCount);\n    const retainedSizes = new Float64Array(nodeCount);\n    const nodeSelfSizes = await nodeSelfSizesPromise;\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; nodeOrdinal++) {\n      dominatorsTree[nodeOrdinal] = dom[nodeOrdinal + 1] - 1;\n      retainedSizes[nodeOrdinal] = nodeSelfSizes[nodeOrdinal];\n    }\n\n    // Then propagate up the retained sizes for each traversed node excluding the root.\n    for (let i = n; i > 1; i--) {\n      const nodeOrdinal = vertex[i] - 1;\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      retainedSizes[dominatorOrdinal] += retainedSizes[nodeOrdinal];\n    }\n\n    return {dominatorsTree, retainedSizes};\n  }\n\n  static buildDominatedNodes(inputs: ArgumentsToBuildDominatedNodes): DominatedNodes {\n    const {nodeCount, dominatorsTree, rootNodeOrdinal, nodeFieldCount} = inputs;\n\n    // Builds up two arrays:\n    //  - \"dominatedNodes\" is a continuous array, where each node owns an\n    //    interval (can be empty) with corresponding dominated nodes.\n    //  - \"indexArray\" is an array of indexes in the \"dominatedNodes\"\n    //    with the same positions as in the _nodeIndex.\n    const indexArray = new Uint32Array(nodeCount + 1);\n    // All nodes except the root have dominators.\n    const dominatedNodes = new Uint32Array(nodeCount - 1);\n\n    // Count the number of dominated nodes for each node. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n\n    let fromNodeOrdinal = 0;\n    let toNodeOrdinal: number = nodeCount;\n    if (rootNodeOrdinal === fromNodeOrdinal) {\n      fromNodeOrdinal = 1;\n    } else if (rootNodeOrdinal === toNodeOrdinal - 1) {\n      toNodeOrdinal = toNodeOrdinal - 1;\n    } else {\n      throw new Error('Root node is expected to be either first or last');\n    }\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      ++indexArray[dominatorsTree[nodeOrdinal]];\n    }\n    // Put in the first slot of each dominatedNodes slice the count of entries\n    // that will be filled.\n    let firstDominatedNodeIndex = 0;\n    for (let i = 0, l = nodeCount; i < l; ++i) {\n      const dominatedCount = dominatedNodes[firstDominatedNodeIndex] = indexArray[i];\n      indexArray[i] = firstDominatedNodeIndex;\n      firstDominatedNodeIndex += dominatedCount;\n    }\n    indexArray[nodeCount] = dominatedNodes.length;\n    // Fill up the dominatedNodes array with indexes of dominated nodes. Skip the root (node at\n    // index 0) as it is the only node that dominates itself.\n    for (let nodeOrdinal = fromNodeOrdinal; nodeOrdinal < toNodeOrdinal; ++nodeOrdinal) {\n      const dominatorOrdinal = dominatorsTree[nodeOrdinal];\n      let dominatedRefIndex = indexArray[dominatorOrdinal];\n      dominatedRefIndex += (--dominatedNodes[dominatedRefIndex]);\n      dominatedNodes[dominatedRefIndex] = nodeOrdinal * nodeFieldCount;\n    }\n\n    return {firstDominatedNodeIndex: indexArray, dominatedNodes};\n  }\n\n  private calculateObjectNames(): void {\n    const {\n      nodes,\n      nodeCount,\n      nodeNameOffset,\n      nodeNativeType,\n      nodeHiddenType,\n      nodeObjectType,\n      nodeCodeType,\n      nodeClosureType,\n      nodeRegExpType,\n    } = this;\n\n    // If the snapshot doesn't contain a detachedness field in each node, then\n    // allocate a separate array so there is somewhere to store the class index.\n    if (this.nodeDetachednessAndClassIndexOffset === -1) {\n      this.detachednessAndClassIndexArray = new Uint32Array(nodeCount);\n    }\n\n    // We'll add some new values to the `strings` array during the processing below.\n    // This map lets us easily find the index for each added string.\n    const stringTable = new Map<string, number>();\n    const getIndexForString = (s: string): number => {\n      let index = stringTable.get(s);\n      if (index === undefined) {\n        index = this.addString(s);\n        stringTable.set(s, index);\n      }\n      return index;\n    };\n\n    const hiddenClassIndex = getIndexForString('(system)');\n    const codeClassIndex = getIndexForString('(compiled code)');\n    const functionClassIndex = getIndexForString('Function');\n    const regExpClassIndex = getIndexForString('RegExp');\n\n    function getNodeClassIndex(node: HeapSnapshotNode): number {\n      switch (node.rawType()) {\n        case nodeHiddenType:\n          return hiddenClassIndex;\n        case nodeObjectType:\n        case nodeNativeType: {\n          let name = node.rawName();\n\n          // If the node name is (for example) '<div id=\"a\">', then the class\n          // name should be just '<div>'. If the node name is already short\n          // enough, like '<div>', we must still call getIndexForString on that\n          // name, because the names added by getIndexForString are not\n          // deduplicated with preexisting strings, and we want all objects with\n          // class name '<div>' to refer to that class name via the same index.\n          // Otherwise, object categorization doesn't work.\n          if (name.startsWith('<')) {\n            const firstSpace = name.indexOf(' ');\n            if (firstSpace !== -1) {\n              name = name.substring(0, firstSpace) + '>';\n            }\n            return getIndexForString(name);\n          }\n          if (name.startsWith('Detached <')) {\n            const firstSpace = name.indexOf(' ', 10);\n            if (firstSpace !== -1) {\n              name = name.substring(0, firstSpace) + '>';\n            }\n            return getIndexForString(name);\n          }\n\n          // Avoid getIndexForString here; the class name index should match the name index.\n          return nodes.getValue(node.nodeIndex + nodeNameOffset);\n        }\n        case nodeCodeType:\n          return codeClassIndex;\n        case nodeClosureType:\n          return functionClassIndex;\n        case nodeRegExpType:\n          return regExpClassIndex;\n        default:\n          return getIndexForString('(' + node.type() + ')');\n      }\n    }\n\n    const node = this.createNode(0);\n    for (let i = 0; i < nodeCount; ++i) {\n      node.setClassIndex(getNodeClassIndex(node));\n      node.nodeIndex = node.nextNodeIndex();\n    }\n  }\n\n  interfaceDefinitions(): string {\n    return JSON.stringify(this.#interfaceDefinitions ?? []);\n  }\n\n  private isPlainJSObject(node: HeapSnapshotNode): boolean {\n    return node.rawType() === this.nodeObjectType && node.rawName() === 'Object';\n  }\n\n  private inferInterfaceDefinitions(): InterfaceDefinition[] {\n    const {edgePropertyType} = this;\n\n    // First, produce a set of candidate definitions by iterating the properties\n    // on every plain JS Object in the snapshot.\n    interface InterfaceDefinitionCandidate extends InterfaceDefinition {\n      // How many objects start with these properties in this order.\n      count: number;\n    }\n    // A map from interface names to their definitions.\n    const candidates = new Map<string, InterfaceDefinitionCandidate>();\n    let totalObjectCount = 0;\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      const node = it.item();\n      if (!this.isPlainJSObject(node)) {\n        continue;\n      }\n      ++totalObjectCount;\n      let interfaceName = '{';\n      const properties: string[] = [];\n      for (let edgeIt = node.edges(); edgeIt.hasNext(); edgeIt.next()) {\n        const edge = edgeIt.item();\n        const edgeName = edge.name();\n        if (edge.rawType() !== edgePropertyType || edgeName === '__proto__') {\n          continue;\n        }\n        const formattedEdgeName = JSHeapSnapshotNode.formatPropertyName(edgeName);\n        if (interfaceName.length > MIN_INTERFACE_PROPERTY_COUNT &&\n            interfaceName.length + formattedEdgeName.length > MAX_INTERFACE_NAME_LENGTH) {\n          break;  // The interface name is getting too long.\n        }\n        if (interfaceName.length !== 1) {\n          interfaceName += ', ';\n        }\n        interfaceName += formattedEdgeName;\n        properties.push(edgeName);\n      }\n      // The empty interface is not very meaningful, and can be sort of misleading\n      // since someone might incorrectly interpret it as objects with no properties.\n      if (properties.length === 0) {\n        continue;\n      }\n      interfaceName += '}';\n      const candidate = candidates.get(interfaceName);\n      if (candidate) {\n        ++candidate.count;\n      } else {\n        candidates.set(interfaceName, {name: interfaceName, properties, count: 1});\n      }\n    }\n\n    // Next, sort the candidates and select the most popular ones. It's possible that\n    // some candidates represent the same properties in different orders, but that's\n    // okay: by sorting here, we ensure that the most popular ordering appears first\n    // in the result list, and the rules for applying interface definitions will prefer\n    // the first matching definition if multiple matches contain the same properties.\n    const sortedCandidates = Array.from(candidates.values());\n    sortedCandidates.sort((a, b) => b.count - a.count);\n    const result: InterfaceDefinition[] = [];\n    const minCount = Math.max(MIN_OBJECT_COUNT_PER_INTERFACE, totalObjectCount / MIN_OBJECT_PROPORTION_PER_INTERFACE);\n    for (let i = 0; i < sortedCandidates.length; ++i) {\n      const candidate = sortedCandidates[i];\n      if (candidate.count < minCount) {\n        break;\n      }\n      result.push(candidate);\n    }\n\n    return result;\n  }\n\n  private applyInterfaceDefinitions(definitions: InterfaceDefinition[]): void {\n    const {edgePropertyType} = this;\n    this.#interfaceDefinitions = definitions;\n\n    // Any computed aggregate data will be wrong after recategorization, so clear it.\n    this.#aggregates = {};\n    this.#aggregatesSortedFlags = {};\n\n    // Information about a named interface.\n    interface MatchInfo {\n      name: string;\n      // The number of properties listed in the interface definition.\n      propertyCount: number;\n      // The position of the interface definition in the list of definitions.\n      index: number;\n    }\n\n    function selectBetterMatch(a: MatchInfo, b: MatchInfo|null): MatchInfo {\n      if (!b || a.propertyCount > b.propertyCount) {\n        return a;\n      }\n      if (b.propertyCount > a.propertyCount) {\n        return b;\n      }\n      return a.index <= b.index ? a : b;\n    }\n\n    // A node in the tree which allows us to search for interfaces matching an object.\n    // Each edge in this tree represents adding a property, starting from an empty\n    // object. Properties must be iterated in sorted order.\n    interface PropertyTreeNode {\n      // All possible successors from this node. Keys are property names.\n      next: Map<string, PropertyTreeNode>;\n      // If this node corresponds to a named interface, then matchInfo contains that name.\n      matchInfo: MatchInfo|null;\n      // The maximum of all keys in `next`. This helps determine when no further transitions\n      // are possible from this node.\n      greatestNext: string|null;\n    }\n\n    // The root node of the tree.\n    const propertyTree: PropertyTreeNode = {\n      next: new Map(),\n      matchInfo: null,\n      greatestNext: null,\n    };\n\n    // Build up the property tree.\n    for (let interfaceIndex = 0; interfaceIndex < definitions.length; ++interfaceIndex) {\n      const definition = definitions[interfaceIndex];\n      const properties = definition.properties.toSorted();\n      let currentNode = propertyTree;\n      for (const property of properties) {\n        const nextMap = currentNode.next;\n        let nextNode = nextMap.get(property);\n        if (!nextNode) {\n          nextNode = {\n            next: new Map(),\n            matchInfo: null,\n            greatestNext: null,\n          };\n          nextMap.set(property, nextNode);\n          if (currentNode.greatestNext === null || currentNode.greatestNext < property) {\n            currentNode.greatestNext = property;\n          }\n        }\n        currentNode = nextNode;\n      }\n      // Only set matchInfo on this node if it wasn't already set, to ensure that\n      // interfaces defined earlier in the list have priority.\n      if (!currentNode.matchInfo) {\n        currentNode.matchInfo = {\n          name: definition.name,\n          propertyCount: properties.length,\n          index: interfaceIndex,\n        };\n      }\n    }\n\n    // The fallback match for objects which don't match any defined interface.\n    const initialMatch: MatchInfo = {\n      name: 'Object',\n      propertyCount: 0,\n      index: Infinity,\n    };\n\n    // Iterate all nodes and check whether they match a named interface, using\n    // the tree constructed above. Then update the class name for each node.\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      const node = it.item();\n      if (!this.isPlainJSObject(node)) {\n        continue;\n      }\n\n      // Collect and sort the properties of this object.\n      const properties: string[] = [];\n      for (let edgeIt = node.edges(); edgeIt.hasNext(); edgeIt.next()) {\n        const edge = edgeIt.item();\n        if (edge.rawType() === edgePropertyType) {\n          properties.push(edge.name());\n        }\n      }\n      properties.sort();\n\n      // We may explore multiple possible paths through the tree, so this set tracks\n      // all states that match with the properties iterated thus far.\n      const states = new Set<PropertyTreeNode>();\n      states.add(propertyTree);\n\n      // This variable represents the best match found thus far. We start by checking\n      // whether there is an interface definition for the empty object.\n      let match = selectBetterMatch(initialMatch, propertyTree.matchInfo);\n\n      // Traverse the tree to find any matches.\n      for (const property of properties) {\n        // Iterate only the states that already exist, not the ones added during the loop below.\n        for (const currentState of Array.from(states.keys())) {\n          if (currentState.greatestNext === null || property >= currentState.greatestNext) {\n            // No further transitions are possible from this state.\n            states.delete(currentState);\n          }\n          const nextState = currentState.next.get(property);\n          if (nextState) {\n            states.add(nextState);\n            match = selectBetterMatch(match, nextState.matchInfo);\n          }\n        }\n      }\n\n      // Update the node's class name accordingly.\n      let classIndex = match === initialMatch ? node.rawNameIndex() : this.#interfaceNames.get(match.name);\n      if (classIndex === undefined) {\n        classIndex = this.addString(match.name);\n        this.#interfaceNames.set(match.name, classIndex);\n      }\n      node.setClassIndex(classIndex);\n    }\n  }\n\n  /**\n   * Iterates children of a node.\n   */\n  private iterateFilteredChildren(\n      nodeOrdinal: number, edgeFilterCallback: (arg0: number) => boolean, childCallback: (arg0: number) => void): void {\n    const beginEdgeIndex = this.firstEdgeIndexes[nodeOrdinal];\n    const endEdgeIndex = this.firstEdgeIndexes[nodeOrdinal + 1];\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += this.edgeFieldsCount) {\n      const childNodeIndex = this.containmentEdges.getValue(edgeIndex + this.edgeToNodeOffset);\n      const childNodeOrdinal = childNodeIndex / this.nodeFieldCount;\n      const type = this.containmentEdges.getValue(edgeIndex + this.edgeTypeOffset);\n      if (!edgeFilterCallback(type)) {\n        continue;\n      }\n      childCallback(childNodeOrdinal);\n    }\n  }\n\n  /**\n   * Adds a string to the snapshot.\n   */\n  private addString(string: string): number {\n    this.strings.push(string);\n    return this.strings.length - 1;\n  }\n\n  /**\n   * The phase propagates whether a node is attached or detached through the\n   * graph and adjusts the low-level representation of nodes.\n   *\n   * State propagation:\n   * 1. Any object reachable from an attached object is itself attached.\n   * 2. Any object reachable from a detached object that is not already\n   *    attached is considered detached.\n   *\n   * Representation:\n   * - Name of any detached node is changed from \"<Name>\"\" to\n   *   \"Detached <Name>\".\n   */\n  private propagateDOMState(): void {\n    if (this.nodeDetachednessAndClassIndexOffset === -1) {\n      return;\n    }\n\n    console.time('propagateDOMState');\n\n    const visited = new Uint8Array(this.nodeCount);\n    const attached: number[] = [];\n    const detached: number[] = [];\n\n    const stringIndexCache = new Map<number, number>();\n    const node = this.createNode(0);\n\n    /**\n     * Adds a 'Detached ' prefix to the name of a node.\n     */\n    const addDetachedPrefixToNodeName = function(snapshot: HeapSnapshot, nodeIndex: number): void {\n      const oldStringIndex = snapshot.nodes.getValue(nodeIndex + snapshot.nodeNameOffset);\n      let newStringIndex = stringIndexCache.get(oldStringIndex);\n      if (newStringIndex === undefined) {\n        newStringIndex = snapshot.addString('Detached ' + snapshot.strings[oldStringIndex]);\n        stringIndexCache.set(oldStringIndex, newStringIndex);\n      }\n      snapshot.nodes.setValue(nodeIndex + snapshot.nodeNameOffset, newStringIndex);\n    };\n\n    /**\n     * Processes a node represented by nodeOrdinal:\n     * - Changes its name based on newState.\n     * - Puts it onto working sets for attached or detached nodes.\n     */\n    const processNode = function(snapshot: HeapSnapshot, nodeOrdinal: number, newState: number): void {\n      if (visited[nodeOrdinal]) {\n        return;\n      }\n\n      const nodeIndex = nodeOrdinal * snapshot.nodeFieldCount;\n\n      // Early bailout: Do not propagate the state (and name change) through JavaScript. Every\n      // entry point into embedder code is a node that knows its own state. All embedder nodes\n      // have their node type set to native.\n      if (snapshot.nodes.getValue(nodeIndex + snapshot.nodeTypeOffset) !== snapshot.nodeNativeType) {\n        visited[nodeOrdinal] = 1;\n        return;\n      }\n\n      node.nodeIndex = nodeIndex;\n      node.setDetachedness(newState);\n\n      if (newState === DOMLinkState.ATTACHED) {\n        attached.push(nodeOrdinal);\n      } else if (newState === DOMLinkState.DETACHED) {\n        // Detached state: Rewire node name.\n        addDetachedPrefixToNodeName(snapshot, nodeIndex);\n        detached.push(nodeOrdinal);\n      }\n\n      visited[nodeOrdinal] = 1;\n    };\n\n    const propagateState = function(snapshot: HeapSnapshot, parentNodeOrdinal: number, newState: number): void {\n      snapshot.iterateFilteredChildren(\n          parentNodeOrdinal,\n          edgeType => ![snapshot.edgeHiddenType, snapshot.edgeInvisibleType, snapshot.edgeWeakType].includes(edgeType),\n          nodeOrdinal => processNode(snapshot, nodeOrdinal, newState));\n    };\n\n    // 1. We re-use the deserialized field to store the propagated state. While\n    //    the state for known nodes is already set, they still need to go\n    //    through processing to have their name adjusted and them enqueued in\n    //    the respective queues.\n    for (let nodeOrdinal = 0; nodeOrdinal < this.nodeCount; ++nodeOrdinal) {\n      node.nodeIndex = nodeOrdinal * this.nodeFieldCount;\n      const state = node.detachedness();\n      // Bail out for objects that have no known state. For all other objects set that state.\n      if (state === DOMLinkState.UNKNOWN) {\n        continue;\n      }\n      processNode(this, nodeOrdinal, state);\n    }\n    // 2. If the parent is attached, then the child is also attached.\n    while (attached.length !== 0) {\n      const nodeOrdinal = (attached.pop() as number);\n      propagateState(this, nodeOrdinal, DOMLinkState.ATTACHED);\n    }\n    // 3. If the parent is not attached, then the child inherits the parent's state.\n    while (detached.length !== 0) {\n      const nodeOrdinal = (detached.pop() as number);\n      node.nodeIndex = nodeOrdinal * this.nodeFieldCount;\n      const nodeState = node.detachedness();\n      // Ignore if the node has been found through propagating forward attached state.\n      if (nodeState === DOMLinkState.ATTACHED) {\n        continue;\n      }\n      propagateState(this, nodeOrdinal, DOMLinkState.DETACHED);\n    }\n\n    console.timeEnd('propagateDOMState');\n  }\n\n  private buildSamples(): void {\n    const samples = this.#rawSamples;\n    if (!samples?.length) {\n      return;\n    }\n    const sampleCount = samples.length / 2;\n    const sizeForRange = new Array(sampleCount);\n    const timestamps = new Array(sampleCount);\n    const lastAssignedIds = new Array(sampleCount);\n\n    const timestampOffset = this.#metaNode.sample_fields.indexOf('timestamp_us');\n    const lastAssignedIdOffset = this.#metaNode.sample_fields.indexOf('last_assigned_id');\n    for (let i = 0; i < sampleCount; i++) {\n      sizeForRange[i] = 0;\n      timestamps[i] = (samples[2 * i + timestampOffset]) / 1000;\n      lastAssignedIds[i] = samples[2 * i + lastAssignedIdOffset];\n    }\n\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      node.nodeIndex = nodeIndex;\n\n      const nodeId = node.id();\n      // JS objects have odd ids, skip native objects.\n      if (nodeId % 2 === 0) {\n        continue;\n      }\n      const rangeIndex =\n          Platform.ArrayUtilities.lowerBound(lastAssignedIds, nodeId, Platform.ArrayUtilities.DEFAULT_COMPARATOR);\n      if (rangeIndex === sampleCount) {\n        // TODO: make heap profiler not allocate while taking snapshot\n        continue;\n      }\n      sizeForRange[rangeIndex] += node.selfSize();\n    }\n    this.#samples = new HeapSnapshotModel.HeapSnapshotModel.Samples(timestamps, lastAssignedIds, sizeForRange);\n  }\n\n  private buildLocationMap(): void {\n    const map = new Map<number, HeapSnapshotModel.HeapSnapshotModel.Location>();\n    const locations = this.#locations;\n\n    for (let i = 0; i < locations.length; i += this.#locationFieldCount) {\n      const nodeIndex = locations[i + this.#locationIndexOffset];\n      const scriptId = locations[i + this.#locationScriptIdOffset];\n      const line = locations[i + this.#locationLineOffset];\n      const col = locations[i + this.#locationColumnOffset];\n      map.set(nodeIndex, new HeapSnapshotModel.HeapSnapshotModel.Location(scriptId, line, col));\n    }\n\n    this.#locationMap = map;\n  }\n\n  getLocation(nodeIndex: number): HeapSnapshotModel.HeapSnapshotModel.Location|null {\n    return this.#locationMap.get(nodeIndex) || null;\n  }\n\n  getSamples(): HeapSnapshotModel.HeapSnapshotModel.Samples|null {\n    return this.#samples;\n  }\n\n  calculateFlags(): void {\n    throw new Error('Not implemented');\n  }\n\n  calculateStatistics(): void {\n    throw new Error('Not implemented');\n  }\n\n  userObjectsMapAndFlag(): {map: Uint8Array, flag: number}|null {\n    throw new Error('Not implemented');\n  }\n\n  calculateSnapshotDiff(\n      baseSnapshotId: string,\n      baseSnapshotAggregates: Record<string, HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff>):\n      Record<string, HeapSnapshotModel.HeapSnapshotModel.Diff> {\n    let snapshotDiff: Record<string, HeapSnapshotModel.HeapSnapshotModel.Diff> = this.#snapshotDiffs[baseSnapshotId];\n    if (snapshotDiff) {\n      return snapshotDiff;\n    }\n    snapshotDiff = ({} as Record<string, HeapSnapshotModel.HeapSnapshotModel.Diff>);\n\n    const aggregates = this.getAggregatesByClassKey(true, 'allObjects');\n    for (const classKey in baseSnapshotAggregates) {\n      const baseAggregate = baseSnapshotAggregates[classKey];\n      const diff = this.calculateDiffForClass(baseAggregate, aggregates[classKey]);\n      if (diff) {\n        snapshotDiff[classKey] = diff;\n      }\n    }\n    const emptyBaseAggregate = new HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff();\n    for (const classKey in aggregates) {\n      if (classKey in baseSnapshotAggregates) {\n        continue;\n      }\n      const classDiff = this.calculateDiffForClass(emptyBaseAggregate, aggregates[classKey]);\n      if (classDiff) {\n        snapshotDiff[classKey] = classDiff;\n      }\n    }\n\n    this.#snapshotDiffs[baseSnapshotId] = snapshotDiff;\n    return snapshotDiff;\n  }\n\n  private calculateDiffForClass(\n      baseAggregate: HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff,\n      aggregate?: HeapSnapshotModel.HeapSnapshotModel.Aggregate): HeapSnapshotModel.HeapSnapshotModel.Diff|null {\n    const baseIds = baseAggregate.ids;\n    const baseIndexes = baseAggregate.indexes;\n    const baseSelfSizes = baseAggregate.selfSizes;\n\n    const indexes = aggregate ? aggregate.idxs : [];\n\n    let i = 0;\n    let j = 0;\n    const l = baseIds.length;\n    const m = indexes.length;\n    const diff = new HeapSnapshotModel.HeapSnapshotModel.Diff(aggregate ? aggregate.name : baseAggregate.name);\n\n    const nodeB = this.createNode(indexes[j]);\n    while (i < l && j < m) {\n      const nodeAId = baseIds[i];\n      if (nodeAId < nodeB.id()) {\n        diff.deletedIndexes.push(baseIndexes[i]);\n        diff.removedCount++;\n        diff.removedSize += baseSelfSizes[i];\n        ++i;\n      } else if (\n          nodeAId >\n          nodeB.id()) {  // Native nodes(e.g. dom groups) may have ids less than max JS object id in the base snapshot\n        diff.addedIndexes.push(indexes[j]);\n        diff.addedCount++;\n        diff.addedSize += nodeB.selfSize();\n        nodeB.nodeIndex = indexes[++j];\n      } else {  // nodeAId === nodeB.id()\n        ++i;\n        nodeB.nodeIndex = indexes[++j];\n      }\n    }\n    while (i < l) {\n      diff.deletedIndexes.push(baseIndexes[i]);\n      diff.removedCount++;\n      diff.removedSize += baseSelfSizes[i];\n      ++i;\n    }\n    while (j < m) {\n      diff.addedIndexes.push(indexes[j]);\n      diff.addedCount++;\n      diff.addedSize += nodeB.selfSize();\n      nodeB.nodeIndex = indexes[++j];\n    }\n    diff.countDelta = diff.addedCount - diff.removedCount;\n    diff.sizeDelta = diff.addedSize - diff.removedSize;\n    if (!diff.addedCount && !diff.removedCount) {\n      return null;\n    }\n    return diff;\n  }\n\n  private nodeForSnapshotObjectId(snapshotObjectId: number): HeapSnapshotNode|null {\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      if (it.node.id() === snapshotObjectId) {\n        return it.node;\n      }\n    }\n    return null;\n  }\n\n  // Converts an internal class key, suitable for categorizing within this\n  // snapshot, to a public class key, which can be used in comparisons\n  // between multiple snapshots.\n  classKeyFromClassKeyInternal(key: string|number): string {\n    return typeof key === 'number' ? (',' + this.strings[key]) : key;\n  }\n\n  nodeClassKey(snapshotObjectId: number): string|null {\n    const node = this.nodeForSnapshotObjectId(snapshotObjectId);\n    if (node) {\n      return this.classKeyFromClassKeyInternal(node.classKeyInternal());\n    }\n    return null;\n  }\n\n  idsOfObjectsWithName(name: string): number[] {\n    const ids = [];\n    for (let it = this.allNodes(); it.hasNext(); it.next()) {\n      if (it.item().name() === name) {\n        ids.push(it.item().id());\n      }\n    }\n    return ids;\n  }\n\n  createEdgesProvider(nodeIndex: number): HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const filter = this.containmentEdgesFilter();\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  createEdgesProviderForTest(nodeIndex: number, filter: ((arg0: HeapSnapshotEdge) => boolean)|null):\n      HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const indexProvider = new HeapSnapshotEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.edges(), indexProvider);\n  }\n\n  retainingEdgesFilter(): ((arg0: HeapSnapshotEdge) => boolean)|null {\n    return null;\n  }\n\n  containmentEdgesFilter(): ((arg0: HeapSnapshotEdge) => boolean)|null {\n    return null;\n  }\n\n  createRetainingEdgesProvider(nodeIndex: number): HeapSnapshotEdgesProvider {\n    const node = this.createNode(nodeIndex);\n    const filter = this.retainingEdgesFilter();\n    const indexProvider = new HeapSnapshotRetainerEdgeIndexProvider(this);\n    return new HeapSnapshotEdgesProvider(this, filter, node.retainers(), indexProvider);\n  }\n\n  createAddedNodesProvider(baseSnapshotId: string, classKey: string): HeapSnapshotNodesProvider {\n    const snapshotDiff = this.#snapshotDiffs[baseSnapshotId];\n    const diffForClass = snapshotDiff[classKey];\n    return new HeapSnapshotNodesProvider(this, diffForClass.addedIndexes);\n  }\n\n  createDeletedNodesProvider(nodeIndexes: number[]): HeapSnapshotNodesProvider {\n    return new HeapSnapshotNodesProvider(this, nodeIndexes);\n  }\n\n  createNodesProviderForClass(classKey: string, nodeFilter: HeapSnapshotModel.HeapSnapshotModel.NodeFilter):\n      HeapSnapshotNodesProvider {\n    return new HeapSnapshotNodesProvider(this, this.aggregatesWithFilter(nodeFilter)[classKey].idxs);\n  }\n\n  private maxJsNodeId(): number {\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    let id = 0;\n    for (let nodeIndex = this.nodeIdOffset; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nextId = nodes.getValue(nodeIndex);\n      // JS objects have odd ids, skip native objects.\n      if (nextId % 2 === 0) {\n        continue;\n      }\n      if (id < nextId) {\n        id = nextId;\n      }\n    }\n    return id;\n  }\n\n  updateStaticData(): HeapSnapshotModel.HeapSnapshotModel.StaticData {\n    return new HeapSnapshotModel.HeapSnapshotModel.StaticData(\n        this.nodeCount, this.rootNodeIndexInternal, this.totalSize, this.maxJsNodeId());\n  }\n\n  ignoreNodeInRetainersView(nodeIndex: number): void {\n    this.#ignoredNodesInRetainersView.add(nodeIndex);\n    this.calculateDistances(/* isForRetainersView=*/ true);\n    this.#updateIgnoredEdgesInRetainersView();\n  }\n\n  unignoreNodeInRetainersView(nodeIndex: number): void {\n    this.#ignoredNodesInRetainersView.delete(nodeIndex);\n    if (this.#ignoredNodesInRetainersView.size === 0) {\n      this.#nodeDistancesForRetainersView = undefined;\n    } else {\n      this.calculateDistances(/* isForRetainersView=*/ true);\n    }\n    this.#updateIgnoredEdgesInRetainersView();\n  }\n\n  unignoreAllNodesInRetainersView(): void {\n    this.#ignoredNodesInRetainersView.clear();\n    this.#nodeDistancesForRetainersView = undefined;\n    this.#updateIgnoredEdgesInRetainersView();\n  }\n\n  #updateIgnoredEdgesInRetainersView(): void {\n    const distances = this.#nodeDistancesForRetainersView;\n    this.#ignoredEdgesInRetainersView.clear();\n    if (distances === undefined) {\n      return;\n    }\n\n    // To retain a value in a WeakMap, both the WeakMap and the corresponding\n    // key must stay alive. If one of those two retainers is unreachable due to\n    // the user ignoring some nodes, then the other retainer edge should also be\n    // shown as unreachable, since it would be insufficient on its own to retain\n    // the value.\n    const unreachableWeakMapEdges = new Platform.MapUtilities.Multimap<number, string>();\n    const noDistance = this.#noDistance;\n    const {nodeCount, nodeFieldCount} = this;\n    const node = this.createNode(0);\n\n    // Populate unreachableWeakMapEdges.\n    for (let nodeOrdinal = 0; nodeOrdinal < nodeCount; ++nodeOrdinal) {\n      if (distances[nodeOrdinal] !== noDistance) {\n        continue;\n      }\n      node.nodeIndex = nodeOrdinal * nodeFieldCount;\n      for (let iter = node.edges(); iter.hasNext(); iter.next()) {\n        const edge = iter.edge;\n        if (!edge.isInternal()) {\n          continue;\n        }\n        const match = this.tryParseWeakMapEdgeName(edge.nameIndex());\n        if (match) {\n          unreachableWeakMapEdges.set(edge.nodeIndex(), match.duplicatedPart);\n        }\n      }\n    }\n\n    // Iterate the retaining edges for the target nodes found in the previous\n    // step and mark any relevant WeakMap edges as ignored.\n    for (const targetNodeIndex of unreachableWeakMapEdges.keys()) {\n      node.nodeIndex = targetNodeIndex;\n      for (let it = node.retainers(); it.hasNext(); it.next()) {\n        const reverseEdge = it.item();\n        if (!reverseEdge.isInternal()) {\n          continue;\n        }\n        const match = this.tryParseWeakMapEdgeName(reverseEdge.nameIndex());\n        if (match && unreachableWeakMapEdges.hasValue(targetNodeIndex, match.duplicatedPart)) {\n          const forwardEdgeIndex = this.retainingEdges[reverseEdge.itemIndex()];\n          this.#ignoredEdgesInRetainersView.add(forwardEdgeIndex);\n        }\n      }\n    }\n  }\n\n  areNodesIgnoredInRetainersView(): boolean {\n    return this.#ignoredNodesInRetainersView.size > 0;\n  }\n\n  getDistanceForRetainersView(nodeIndex: number): number {\n    const nodeOrdinal = nodeIndex / this.nodeFieldCount;\n    const distances = this.#nodeDistancesForRetainersView ?? this.nodeDistances;\n    const distance = distances[nodeOrdinal];\n    if (distance === this.#noDistance) {\n      // An unreachable node should be sorted to the end, not the beginning.\n      // To give such nodes a reasonable sorting order, we add a very large\n      // number to the original distance computed without ignoring any nodes.\n      return Math.max(0, this.nodeDistances[nodeOrdinal]) + HeapSnapshotModel.HeapSnapshotModel.baseUnreachableDistance;\n    }\n    return distance;\n  }\n\n  isNodeIgnoredInRetainersView(nodeIndex: number): boolean {\n    return this.#ignoredNodesInRetainersView.has(nodeIndex);\n  }\n\n  isEdgeIgnoredInRetainersView(edgeIndex: number): boolean {\n    return this.#ignoredEdgesInRetainersView.has(edgeIndex);\n  }\n}\n\ninterface HeapSnapshotMetaInfo {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  location_fields: string[];\n  node_fields: string[];\n  node_types: string[][];\n  edge_fields: string[];\n  edge_types: string[][];\n  trace_function_info_fields: string[];\n  trace_node_fields: string[];\n  sample_fields: string[];\n  type_strings: Record<string, string>;\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport interface HeapSnapshotHeader {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  title: string;\n  meta: HeapSnapshotMetaInfo;\n  node_count: number;\n  edge_count: number;\n  trace_function_count: number;\n  root_index: number;\n  extra_native_bytes?: number;\n  /* eslint-enable @typescript-eslint/naming-convention */\n}\n\nexport abstract class HeapSnapshotItemProvider {\n  protected readonly iterator: HeapSnapshotItemIterator;\n  readonly #indexProvider: HeapSnapshotItemIndexProvider;\n  readonly #isEmptyInternal: boolean;\n  protected iterationOrder: number[]|null;\n  protected currentComparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig|null;\n  #sortedPrefixLength: number;\n  #sortedSuffixLength: number;\n  constructor(iterator: HeapSnapshotItemIterator, indexProvider: HeapSnapshotItemIndexProvider) {\n    this.iterator = iterator;\n    this.#indexProvider = indexProvider;\n    this.#isEmptyInternal = !iterator.hasNext();\n    this.iterationOrder = null;\n    this.currentComparator = null;\n    this.#sortedPrefixLength = 0;\n    this.#sortedSuffixLength = 0;\n  }\n\n  protected createIterationOrder(): void {\n    if (this.iterationOrder) {\n      return;\n    }\n    this.iterationOrder = [];\n    for (let iterator = this.iterator; iterator.hasNext(); iterator.next()) {\n      this.iterationOrder.push(iterator.item().itemIndex());\n    }\n  }\n\n  isEmpty(): boolean {\n    return this.#isEmptyInternal;\n  }\n\n  serializeItemsRange(begin: number, end: number): HeapSnapshotModel.HeapSnapshotModel.ItemsRange {\n    this.createIterationOrder();\n    if (begin > end) {\n      throw new Error('Start position > end position: ' + begin + ' > ' + end);\n    }\n\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order undefined');\n    }\n\n    if (end > this.iterationOrder.length) {\n      end = this.iterationOrder.length;\n    }\n    if (this.#sortedPrefixLength < end && begin < this.iterationOrder.length - this.#sortedSuffixLength &&\n        this.currentComparator) {\n      const currentComparator = this.currentComparator;\n      this.sort(\n          currentComparator, this.#sortedPrefixLength, this.iterationOrder.length - 1 - this.#sortedSuffixLength, begin,\n          end - 1);\n      if (begin <= this.#sortedPrefixLength) {\n        this.#sortedPrefixLength = end;\n      }\n      if (end >= this.iterationOrder.length - this.#sortedSuffixLength) {\n        this.#sortedSuffixLength = this.iterationOrder.length - begin;\n      }\n    }\n    let position = begin;\n    const count = end - begin;\n    const result = new Array(count);\n    for (let i = 0; i < count; ++i) {\n      const itemIndex = this.iterationOrder[position++];\n      const item = this.#indexProvider.itemForIndex(itemIndex);\n      result[i] = item.serialize();\n    }\n    return new HeapSnapshotModel.HeapSnapshotModel.ItemsRange(begin, end, this.iterationOrder.length, result);\n  }\n\n  sortAndRewind(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig): void {\n    this.currentComparator = comparator;\n    this.#sortedPrefixLength = 0;\n    this.#sortedSuffixLength = 0;\n  }\n\n  abstract sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void;\n}\n\nexport class HeapSnapshotEdgesProvider extends HeapSnapshotItemProvider {\n  snapshot: HeapSnapshot;\n  constructor(\n      snapshot: HeapSnapshot, filter: ((arg0: HeapSnapshotEdge) => boolean)|null,\n      edgesIter: HeapSnapshotEdgeIterator|HeapSnapshotRetainerEdgeIterator,\n      indexProvider: HeapSnapshotItemIndexProvider) {\n    const iter = filter ? new HeapSnapshotFilteredIterator(edgesIter, (filter as (arg0: HeapSnapshotItem) => boolean)) :\n                          edgesIter;\n    super(iter, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void {\n    const fieldName1 = comparator.fieldName1;\n    const fieldName2 = comparator.fieldName2;\n    const ascending1 = comparator.ascending1;\n    const ascending2 = comparator.ascending2;\n\n    const edgeA = (this.iterator.item() as HeapSnapshotEdge | HeapSnapshotRetainerEdge).clone();\n    const edgeB = edgeA.clone();\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n\n    function compareEdgeField(fieldName: string, ascending: boolean, indexA: number, indexB: number): number {\n      edgeA.edgeIndex = indexA;\n      edgeB.edgeIndex = indexB;\n      let result = 0;\n      if (fieldName === '!edgeName') {\n        if (edgeB.name() === '__proto__') {\n          return -1;\n        }\n        if (edgeA.name() === '__proto__') {\n          return 1;\n        }\n        result = edgeA.hasStringName() === edgeB.hasStringName() ?\n            (edgeA.name() < edgeB.name() ? -1 : (edgeA.name() > edgeB.name() ? 1 : 0)) :\n            (edgeA.hasStringName() ? -1 : 1);\n      } else {\n        result = edgeA.getValueForSorting(fieldName) - edgeB.getValueForSorting(fieldName);\n      }\n      return ascending ? result : -result;\n    }\n\n    function compareNodeField(fieldName: string, ascending: boolean, indexA: number, indexB: number): number {\n      edgeA.edgeIndex = indexA;\n      nodeA.nodeIndex = edgeA.nodeIndex();\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const valueA = (nodeA as any)[fieldName]();\n\n      edgeB.edgeIndex = indexB;\n      nodeB.nodeIndex = edgeB.nodeIndex();\n      // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const valueB = (nodeB as any)[fieldName]();\n\n      const result = valueA < valueB ? -1 : (valueA > valueB ? 1 : 0);\n      return ascending ? result : -result;\n    }\n\n    function compareEdgeAndEdge(indexA: number, indexB: number): number {\n      let result = compareEdgeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareEdgeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareEdgeAndNode(indexA: number, indexB: number): number {\n      let result = compareEdgeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareNodeAndEdge(indexA: number, indexB: number): number {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareEdgeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    function compareNodeAndNode(indexA: number, indexB: number): number {\n      let result = compareNodeField(fieldName1, ascending1, indexA, indexB);\n      if (result === 0) {\n        result = compareNodeField(fieldName2, ascending2, indexA, indexB);\n      }\n      if (result === 0) {\n        return indexA - indexB;\n      }\n      return result;\n    }\n\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    function isEdgeFieldName(fieldName: string): boolean {\n      return fieldName.startsWith('!edge');\n    }\n\n    if (isEdgeFieldName(fieldName1)) {\n      if (isEdgeFieldName(fieldName2)) {\n        Platform.ArrayUtilities.sortRange(\n            this.iterationOrder, compareEdgeAndEdge, leftBound, rightBound, windowLeft, windowRight);\n      } else {\n        Platform.ArrayUtilities.sortRange(\n            this.iterationOrder, compareEdgeAndNode, leftBound, rightBound, windowLeft, windowRight);\n      }\n    } else if (isEdgeFieldName(fieldName2)) {\n      Platform.ArrayUtilities.sortRange(\n          this.iterationOrder, compareNodeAndEdge, leftBound, rightBound, windowLeft, windowRight);\n    } else {\n      Platform.ArrayUtilities.sortRange(\n          this.iterationOrder, compareNodeAndNode, leftBound, rightBound, windowLeft, windowRight);\n    }\n  }\n}\n\nexport class HeapSnapshotNodesProvider extends HeapSnapshotItemProvider {\n  snapshot: HeapSnapshot;\n  constructor(snapshot: HeapSnapshot, nodeIndexes: number[]|Uint32Array) {\n    const indexProvider = new HeapSnapshotNodeIndexProvider(snapshot);\n    const it = new HeapSnapshotIndexRangeIterator(indexProvider, nodeIndexes);\n    super(it, indexProvider);\n    this.snapshot = snapshot;\n  }\n\n  nodePosition(snapshotObjectId: number): number {\n    this.createIterationOrder();\n    const node = this.snapshot.createNode();\n    let i = 0;\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    for (; i < this.iterationOrder.length; i++) {\n      node.nodeIndex = this.iterationOrder[i];\n      if (node.id() === snapshotObjectId) {\n        break;\n      }\n    }\n    if (i === this.iterationOrder.length) {\n      return -1;\n    }\n    const targetNodeIndex = this.iterationOrder[i];\n    let smallerCount = 0;\n\n    const currentComparator = (this.currentComparator as HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig);\n    const compare = this.buildCompareFunction(currentComparator);\n    for (let i = 0; i < this.iterationOrder.length; i++) {\n      if (compare(this.iterationOrder[i], targetNodeIndex) < 0) {\n        ++smallerCount;\n      }\n    }\n    return smallerCount;\n  }\n\n  private buildCompareFunction(comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig):\n      (arg0: number, arg1: number) => number {\n    const nodeA = this.snapshot.createNode();\n    const nodeB = this.snapshot.createNode();\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const fieldAccessor1 = (nodeA as any)[comparator.fieldName1];\n    // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const fieldAccessor2 = (nodeA as any)[comparator.fieldName2];\n    const ascending1 = comparator.ascending1 ? 1 : -1;\n    const ascending2 = comparator.ascending2 ? 1 : -1;\n\n    function sortByNodeField(fieldAccessor: () => void, ascending: number): number {\n      const valueA = fieldAccessor.call(nodeA);\n      const valueB = fieldAccessor.call(nodeB);\n      return valueA < valueB ? -ascending : (valueA > valueB ? ascending : 0);\n    }\n\n    function sortByComparator(indexA: number, indexB: number): number {\n      nodeA.nodeIndex = indexA;\n      nodeB.nodeIndex = indexB;\n      let result = sortByNodeField(fieldAccessor1, ascending1);\n      if (result === 0) {\n        result = sortByNodeField(fieldAccessor2, ascending2);\n      }\n      return result || indexA - indexB;\n    }\n\n    return sortByComparator;\n  }\n\n  sort(\n      comparator: HeapSnapshotModel.HeapSnapshotModel.ComparatorConfig, leftBound: number, rightBound: number,\n      windowLeft: number, windowRight: number): void {\n    if (!this.iterationOrder) {\n      throw new Error('Iteration order not defined');\n    }\n\n    Platform.ArrayUtilities.sortRange(\n        this.iterationOrder, this.buildCompareFunction(comparator), leftBound, rightBound, windowLeft, windowRight);\n  }\n}\n\nexport class JSHeapSnapshot extends HeapSnapshot {\n  readonly nodeFlags: {\n    // bit flags in 8-bit value\n    canBeQueried: number,\n    detachedDOMTreeNode: number,\n    pageObject:\n        number,  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n  };\n  private flags!: Uint8Array;\n  #statistics?: HeapSnapshotModel.HeapSnapshotModel.Statistics;\n  constructor(profile: Profile, progress: HeapSnapshotProgress) {\n    super(profile, progress);\n    this.nodeFlags = {\n      // bit flags in 8-bit value\n      canBeQueried: 1,\n      detachedDOMTreeNode: 2,\n      pageObject:\n          4,  // The idea is to track separately the objects owned by the page and the objects owned by debugger.\n    };\n  }\n\n  createNode(nodeIndex?: number): JSHeapSnapshotNode {\n    return new JSHeapSnapshotNode(this, nodeIndex === undefined ? -1 : nodeIndex);\n  }\n\n  createEdge(edgeIndex: number): JSHeapSnapshotEdge {\n    return new JSHeapSnapshotEdge(this, edgeIndex);\n  }\n\n  createRetainingEdge(retainerIndex: number): JSHeapSnapshotRetainerEdge {\n    return new JSHeapSnapshotRetainerEdge(this, retainerIndex);\n  }\n\n  override containmentEdgesFilter(): (arg0: HeapSnapshotEdge) => boolean {\n    return (edge: HeapSnapshotEdge): boolean => !edge.isInvisible();\n  }\n\n  override retainingEdgesFilter(): (arg0: HeapSnapshotEdge) => boolean {\n    const containmentEdgesFilter = this.containmentEdgesFilter();\n    function filter(edge: HeapSnapshotEdge): boolean {\n      return containmentEdgesFilter(edge) && !edge.node().isRoot() && !edge.isWeak();\n    }\n    return filter;\n  }\n\n  override calculateFlags(): void {\n    this.flags = new Uint8Array(this.nodeCount);\n    this.markDetachedDOMTreeNodes();\n    this.markQueriableHeapObjects();\n    this.markPageOwnedNodes();\n  }\n\n  #hasUserRoots(): boolean {\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      if (this.isUserRoot(iter.edge.node())) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  // Updates the shallow sizes for \"owned\" objects of types kArray or kHidden to\n  // zero, and add their sizes to the \"owner\" object instead.\n  override calculateShallowSizes(): void {\n    // If there are no user roots, then that means the snapshot was produced with\n    // the \"expose internals\" option enabled. In that case, we should faithfully\n    // represent the actual memory allocations rather than attempting to make the\n    // output more understandable to web developers.\n    if (!this.#hasUserRoots()) {\n      return;\n    }\n\n    const {nodeCount, nodes, nodeFieldCount, nodeSelfSizeOffset} = this;\n\n    const kUnvisited = 0xffffffff;\n    const kHasMultipleOwners = 0xfffffffe;\n    if (nodeCount >= kHasMultipleOwners) {\n      throw new Error('Too many nodes for calculateShallowSizes');\n    }\n    // For each node in order, `owners` will contain the index of the owning\n    // node or one of the two values kUnvisited or kHasMultipleOwners. The\n    // indexes in this array are NOT already multiplied by nodeFieldCount.\n    const owners = new Uint32Array(nodeCount);\n    // The worklist contains the indexes of nodes which should be visited during\n    // the second loop below. The order of visiting doesn't matter. The indexes\n    // in this array are NOT already multiplied by nodeFieldCount.\n    const worklist: number[] = [];\n\n    const node = this.createNode(0);\n    for (let i = 0; i < nodeCount; ++i) {\n      if (node.isHidden() || node.isArray() || (node.isNative() && node.rawName() === 'system / ExternalStringData')) {\n        owners[i] = kUnvisited;\n      } else {\n        // The node owns itself.\n        owners[i] = i;\n        worklist.push(i);\n      }\n      node.nodeIndex = node.nextNodeIndex();\n    }\n\n    while (worklist.length !== 0) {\n      const id = worklist.pop() as number;\n      const owner = owners[id];\n      node.nodeIndex = id * nodeFieldCount;\n      for (let iter = node.edges(); iter.hasNext(); iter.next()) {\n        const edge = iter.edge;\n        if (edge.isWeak()) {\n          continue;\n        }\n        const targetId = edge.nodeIndex() / nodeFieldCount;\n        switch (owners[targetId]) {\n          case kUnvisited:\n            owners[targetId] = owner;\n            worklist.push(targetId);\n            break;\n          case targetId:\n          case owner:\n          case kHasMultipleOwners:\n            // There is no change necessary if the target is already marked as:\n            // * owned by itself,\n            // * owned by the owner of the current source node, or\n            // * owned by multiple nodes.\n            break;\n          default:\n            owners[targetId] = kHasMultipleOwners;\n            // It is possible that this node is already in the worklist\n            // somewhere, but visiting it an extra time is not harmful. The\n            // iteration is guaranteed to complete because each node can only be\n            // added twice to the worklist: once when changing from kUnvisited\n            // to a specific owner, and a second time when changing from that\n            // owner to kHasMultipleOwners.\n            worklist.push(targetId);\n            break;\n        }\n      }\n    }\n\n    for (let i = 0; i < nodeCount; ++i) {\n      const ownerId = owners[i];\n      switch (ownerId) {\n        case kUnvisited:\n        case kHasMultipleOwners:\n        case i:\n          break;\n        default: {\n          const ownedNodeIndex = i * nodeFieldCount;\n          const ownerNodeIndex = ownerId * nodeFieldCount;\n          node.nodeIndex = ownerNodeIndex;\n          if (node.isSynthetic() || node.isRoot()) {\n            // Adding shallow size to synthetic or root nodes is not useful.\n            break;\n          }\n          const sizeToTransfer = nodes.getValue(ownedNodeIndex + nodeSelfSizeOffset);\n          nodes.setValue(ownedNodeIndex + nodeSelfSizeOffset, 0);\n          nodes.setValue(\n              ownerNodeIndex + nodeSelfSizeOffset,\n              nodes.getValue(ownerNodeIndex + nodeSelfSizeOffset) + sizeToTransfer);\n          break;\n        }\n      }\n    }\n  }\n\n  override calculateDistances(isForRetainersView: boolean): void {\n    const pendingEphemeronEdges = new Set<string>();\n    const snapshot = this;\n    function filter(node: HeapSnapshotNode, edge: HeapSnapshotEdge): boolean {\n      if (node.isHidden() && edge.name() === 'sloppy_function_map' && node.rawName() === 'system / NativeContext') {\n        return false;\n      }\n      if (node.isArray() && node.rawName() === '(map descriptors)') {\n        // DescriptorArrays are fixed arrays used to hold instance descriptors.\n        // The format of the these objects is:\n        //   [0]: Number of descriptors\n        //   [1]: Either Smi(0) if uninitialized, or a pointer to small fixed array:\n        //          [0]: pointer to fixed array with enum cache\n        //          [1]: either Smi(0) or pointer to fixed array with indices\n        //   [i*3+2]: i-th key\n        //   [i*3+3]: i-th type\n        //   [i*3+4]: i-th descriptor\n        // As long as maps may share descriptor arrays some of the descriptor\n        // links may not be valid for all the maps. We just skip\n        // all the descriptor links when calculating distances.\n        // For more details see http://crbug.com/413608\n        const index = parseInt(edge.name(), 10);\n        return index < 2 || (index % 3) !== 1;\n      }\n      if (edge.isInternal()) {\n        // Snapshots represent WeakMap values as being referenced by two edges:\n        // one from the WeakMap, and a second from the corresponding key. To\n        // avoid the case described in crbug.com/1290800, we should set the\n        // distance of that value to the greater of (WeakMap+1, key+1). This\n        // part of the filter skips the first edge in the matched pair of edges,\n        // so that the distance gets set based on the second, which should be\n        // greater or equal due to traversal order.\n        const match = snapshot.tryParseWeakMapEdgeName(edge.nameIndex());\n        if (match) {\n          if (!pendingEphemeronEdges.delete(match.duplicatedPart)) {\n            pendingEphemeronEdges.add(match.duplicatedPart);\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    super.calculateDistances(isForRetainersView, filter);\n  }\n\n  override isUserRoot(node: HeapSnapshotNode): boolean {\n    return node.isUserRoot() || node.isDocumentDOMTreesRoot();\n  }\n\n  override userObjectsMapAndFlag(): {map: Uint8Array, flag: number}|null {\n    return {map: this.flags, flag: this.nodeFlags.pageObject};\n  }\n\n  flagsOfNode(node: HeapSnapshotNode): number {\n    return this.flags[node.nodeIndex / this.nodeFieldCount];\n  }\n\n  private markDetachedDOMTreeNodes(): void {\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodeNativeType = this.nodeNativeType;\n    const nodeTypeOffset = this.nodeTypeOffset;\n    const flag = this.nodeFlags.detachedDOMTreeNode;\n    const node = this.rootNode();\n    for (let nodeIndex = 0, ordinal = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount, ordinal++) {\n      const nodeType = nodes.getValue(nodeIndex + nodeTypeOffset);\n      if (nodeType !== nodeNativeType) {\n        continue;\n      }\n      node.nodeIndex = nodeIndex;\n      if (node.name().startsWith('Detached ')) {\n        this.flags[ordinal] |= flag;\n      }\n    }\n  }\n\n  private markQueriableHeapObjects(): void {\n    // Allow runtime properties query for objects accessible from Window objects\n    // via regular properties, and for DOM wrappers. Trying to access random objects\n    // can cause a crash due to inconsistent state of internal properties of wrappers.\n    const flag = this.nodeFlags.canBeQueried;\n    const hiddenEdgeType = this.edgeHiddenType;\n    const internalEdgeType = this.edgeInternalType;\n    const invisibleEdgeType = this.edgeInvisibleType;\n    const weakEdgeType = this.edgeWeakType;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this.nodeFieldCount;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n\n    const flags = this.flags;\n    const list: number[] = [];\n\n    for (let iter = this.rootNode().edges(); iter.hasNext(); iter.next()) {\n      if (iter.edge.node().isUserRoot()) {\n        list.push(iter.edge.node().nodeIndex / nodeFieldCount);\n      }\n    }\n\n    while (list.length) {\n      const nodeOrdinal = (list.pop() as number);\n      if (flags[nodeOrdinal] & flag) {\n        continue;\n      }\n      flags[nodeOrdinal] |= flag;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & flag) {\n          continue;\n        }\n        const type = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n        if (type === hiddenEdgeType || type === invisibleEdgeType || type === internalEdgeType ||\n            type === weakEdgeType) {\n          continue;\n        }\n        list.push(childNodeOrdinal);\n      }\n    }\n  }\n\n  private markPageOwnedNodes(): void {\n    const edgeShortcutType = this.edgeShortcutType;\n    const edgeElementType = this.edgeElementType;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeWeakType = this.edgeWeakType;\n    const firstEdgeIndexes = this.firstEdgeIndexes;\n    const containmentEdges = this.containmentEdges;\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodesCount = this.nodeCount;\n\n    const flags = this.flags;\n    const pageObjectFlag = this.nodeFlags.pageObject;\n\n    const nodesToVisit = new Uint32Array(nodesCount);\n    let nodesToVisitLength = 0;\n\n    const rootNodeOrdinal = this.rootNodeIndexInternal / nodeFieldCount;\n    const node = this.rootNode();\n\n    // Populate the entry points. They are Window objects and DOM Tree Roots.\n    for (let edgeIndex = firstEdgeIndexes[rootNodeOrdinal], endEdgeIndex = firstEdgeIndexes[rootNodeOrdinal + 1];\n         edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n      const nodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n      if (edgeType === edgeElementType) {\n        node.nodeIndex = nodeIndex;\n        if (!node.isDocumentDOMTreesRoot()) {\n          continue;\n        }\n      } else if (edgeType !== edgeShortcutType) {\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      nodesToVisit[nodesToVisitLength++] = nodeOrdinal;\n      flags[nodeOrdinal] |= pageObjectFlag;\n    }\n\n    // Mark everything reachable with the pageObject flag.\n    while (nodesToVisitLength) {\n      const nodeOrdinal = nodesToVisit[--nodesToVisitLength];\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n        const childNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n        const childNodeOrdinal = childNodeIndex / nodeFieldCount;\n        if (flags[childNodeOrdinal] & pageObjectFlag) {\n          continue;\n        }\n        const type = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n        if (type === edgeWeakType) {\n          continue;\n        }\n        nodesToVisit[nodesToVisitLength++] = childNodeOrdinal;\n        flags[childNodeOrdinal] |= pageObjectFlag;\n      }\n    }\n  }\n\n  override calculateStatistics(): void {\n    const nodeFieldCount = this.nodeFieldCount;\n    const nodes = this.nodes;\n    const nodesLength = nodes.length;\n    const nodeTypeOffset = this.nodeTypeOffset;\n    const nodeSizeOffset = this.nodeSelfSizeOffset;\n    const nodeNativeType = this.nodeNativeType;\n    const nodeCodeType = this.nodeCodeType;\n    const nodeConsStringType = this.nodeConsStringType;\n    const nodeSlicedStringType = this.nodeSlicedStringType;\n    const nodeHiddenType = this.nodeHiddenType;\n    const nodeStringType = this.nodeStringType;\n    let sizeNative = this.profile.snapshot.extra_native_bytes ?? 0;\n    let sizeTypedArrays = 0;\n    let sizeCode = 0;\n    let sizeStrings = 0;\n    let sizeJSArrays = 0;\n    let sizeSystem = 0;\n    const node = this.rootNode();\n    for (let nodeIndex = 0; nodeIndex < nodesLength; nodeIndex += nodeFieldCount) {\n      const nodeSize = nodes.getValue(nodeIndex + nodeSizeOffset);\n      const nodeType = nodes.getValue(nodeIndex + nodeTypeOffset);\n      if (nodeType === nodeHiddenType) {\n        sizeSystem += nodeSize;\n        continue;\n      }\n      node.nodeIndex = nodeIndex;\n      if (nodeType === nodeNativeType) {\n        sizeNative += nodeSize;\n        if (node.rawName() === 'system / JSArrayBufferData') {\n          sizeTypedArrays += nodeSize;\n        }\n      } else if (nodeType === nodeCodeType) {\n        sizeCode += nodeSize;\n      } else if (nodeType === nodeConsStringType || nodeType === nodeSlicedStringType || nodeType === nodeStringType) {\n        sizeStrings += nodeSize;\n      } else if (node.rawName() === 'Array') {\n        sizeJSArrays += this.calculateArraySize(node);\n      }\n    }\n    this.#statistics = {\n      total: this.totalSize,\n      native: {\n        total: sizeNative,\n        typedArrays: sizeTypedArrays,\n      },\n      v8heap: {\n        total: this.totalSize - sizeNative,\n        code: sizeCode,\n        jsArrays: sizeJSArrays,\n        strings: sizeStrings,\n        system: sizeSystem,\n      }\n    };\n  }\n\n  private calculateArraySize(node: HeapSnapshotNode): number {\n    let size = node.selfSize();\n    const beginEdgeIndex = node.edgeIndexesStart();\n    const endEdgeIndex = node.edgeIndexesEnd();\n    const containmentEdges = this.containmentEdges;\n    const strings = this.strings;\n    const edgeToNodeOffset = this.edgeToNodeOffset;\n    const edgeTypeOffset = this.edgeTypeOffset;\n    const edgeNameOffset = this.edgeNameOffset;\n    const edgeFieldsCount = this.edgeFieldsCount;\n    const edgeInternalType = this.edgeInternalType;\n    for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex; edgeIndex += edgeFieldsCount) {\n      const edgeType = containmentEdges.getValue(edgeIndex + edgeTypeOffset);\n      if (edgeType !== edgeInternalType) {\n        continue;\n      }\n      const edgeName = strings[containmentEdges.getValue(edgeIndex + edgeNameOffset)];\n      if (edgeName !== 'elements') {\n        continue;\n      }\n      const elementsNodeIndex = containmentEdges.getValue(edgeIndex + edgeToNodeOffset);\n      node.nodeIndex = elementsNodeIndex;\n      if (node.retainersCount() === 1) {\n        size += node.selfSize();\n      }\n      break;\n    }\n    return size;\n  }\n\n  getStatistics(): HeapSnapshotModel.HeapSnapshotModel.Statistics {\n    return this.#statistics as HeapSnapshotModel.HeapSnapshotModel.Statistics;\n  }\n}\n\n// Creates and initializes a JSHeapSnapshot using only one thread.\nexport async function createJSHeapSnapshotForTesting(profile: Profile): Promise<JSHeapSnapshot> {\n  const result = new JSHeapSnapshot(profile, new HeapSnapshotProgress());\n  const channel = new MessageChannel();\n  new SecondaryInitManager(channel.port2);\n  await result.initialize(channel.port1);\n  return result;\n}\n\nexport class JSHeapSnapshotNode extends HeapSnapshotNode {\n  canBeQueried(): boolean {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    const flags = snapshot.flagsOfNode(this);\n    return Boolean(flags & snapshot.nodeFlags.canBeQueried);\n  }\n\n  override name(): string {\n    const snapshot = this.snapshot;\n    if (this.rawType() === snapshot.nodeConsStringType) {\n      return this.consStringName();\n    }\n    if (this.rawType() === snapshot.nodeObjectType && this.rawName() === 'Object') {\n      return this.#plainObjectName();\n    }\n    return this.rawName();\n  }\n\n  private consStringName(): string {\n    const snapshot = this.snapshot;\n    const consStringType = snapshot.nodeConsStringType;\n    const edgeInternalType = snapshot.edgeInternalType;\n    const edgeFieldsCount = snapshot.edgeFieldsCount;\n    const edgeToNodeOffset = snapshot.edgeToNodeOffset;\n    const edgeTypeOffset = snapshot.edgeTypeOffset;\n    const edgeNameOffset = snapshot.edgeNameOffset;\n    const strings = snapshot.strings;\n    const edges = snapshot.containmentEdges;\n    const firstEdgeIndexes = snapshot.firstEdgeIndexes;\n    const nodeFieldCount = snapshot.nodeFieldCount;\n    const nodeTypeOffset = snapshot.nodeTypeOffset;\n    const nodeNameOffset = snapshot.nodeNameOffset;\n    const nodes = snapshot.nodes;\n    const nodesStack = [];\n    nodesStack.push(this.nodeIndex);\n    let name = '';\n\n    while (nodesStack.length && name.length < 1024) {\n      const nodeIndex = (nodesStack.pop() as number);\n      if (nodes.getValue(nodeIndex + nodeTypeOffset) !== consStringType) {\n        name += strings[nodes.getValue(nodeIndex + nodeNameOffset)];\n        continue;\n      }\n      const nodeOrdinal = nodeIndex / nodeFieldCount;\n      const beginEdgeIndex = firstEdgeIndexes[nodeOrdinal];\n      const endEdgeIndex = firstEdgeIndexes[nodeOrdinal + 1];\n      let firstNodeIndex = 0;\n      let secondNodeIndex = 0;\n      for (let edgeIndex = beginEdgeIndex; edgeIndex < endEdgeIndex && (!firstNodeIndex || !secondNodeIndex);\n           edgeIndex += edgeFieldsCount) {\n        const edgeType = edges.getValue(edgeIndex + edgeTypeOffset);\n        if (edgeType === edgeInternalType) {\n          const edgeName = strings[edges.getValue(edgeIndex + edgeNameOffset)];\n          if (edgeName === 'first') {\n            firstNodeIndex = edges.getValue(edgeIndex + edgeToNodeOffset);\n          } else if (edgeName === 'second') {\n            secondNodeIndex = edges.getValue(edgeIndex + edgeToNodeOffset);\n          }\n        }\n      }\n      nodesStack.push(secondNodeIndex);\n      nodesStack.push(firstNodeIndex);\n    }\n    return name;\n  }\n\n  // Creates a name for plain JS objects, which looks something like\n  // '{propName, otherProp, thirdProp, ..., secondToLastProp, lastProp}'.\n  // A variable number of property names is included, depending on the length\n  // of the property names, so that the result fits nicely in a reasonably\n  // sized DevTools window.\n  #plainObjectName(): string {\n    const snapshot = this.snapshot;\n    const {edgeFieldsCount, edgePropertyType} = snapshot;\n    const edge = snapshot.createEdge(0);\n    let categoryNameStart = '{';\n    let categoryNameEnd = '}';\n    let edgeIndexFromStart = this.edgeIndexesStart();\n    let edgeIndexFromEnd = this.edgeIndexesEnd() - edgeFieldsCount;\n    let nextFromEnd = false;\n    while (edgeIndexFromStart <= edgeIndexFromEnd) {\n      edge.edgeIndex = nextFromEnd ? edgeIndexFromEnd : edgeIndexFromStart;\n\n      // Skip non-property edges and the special __proto__ property.\n      if (edge.rawType() !== edgePropertyType || edge.name() === '__proto__') {\n        if (nextFromEnd) {\n          edgeIndexFromEnd -= edgeFieldsCount;\n        } else {\n          edgeIndexFromStart += edgeFieldsCount;\n        }\n        continue;\n      }\n\n      const formatted = JSHeapSnapshotNode.formatPropertyName(edge.name());\n\n      // Always include at least one property, regardless of its length. Beyond that point,\n      // only include more properties if the name isn't too long.\n      if (categoryNameStart.length > 1 && categoryNameStart.length + categoryNameEnd.length + formatted.length > 100) {\n        break;\n      }\n\n      if (nextFromEnd) {\n        edgeIndexFromEnd -= edgeFieldsCount;\n        if (categoryNameEnd.length > 1) {\n          categoryNameEnd = ', ' + categoryNameEnd;\n        }\n        categoryNameEnd = formatted + categoryNameEnd;\n      } else {\n        edgeIndexFromStart += edgeFieldsCount;\n        if (categoryNameStart.length > 1) {\n          categoryNameStart += ', ';\n        }\n        categoryNameStart += formatted;\n      }\n      nextFromEnd = !nextFromEnd;\n    }\n    if (edgeIndexFromStart <= edgeIndexFromEnd) {\n      categoryNameStart += ', ';\n    }\n    if (categoryNameEnd.length > 1) {\n      categoryNameStart += ', ';\n    }\n    return categoryNameStart + categoryNameEnd;\n  }\n\n  static formatPropertyName(name: string): string {\n    // We don't need a strict test for whether a property name follows the\n    // rules for being a JS identifier, but property names containing commas,\n    // quotation marks, or braces could cause confusion, so we'll escape those.\n    if (/[,'\"{}]/.test(name)) {\n      name = JSON.stringify({[name]: 0});\n      name = name.substring(1, name.length - 3);\n    }\n    return name;\n  }\n\n  override id(): number {\n    const snapshot = this.snapshot;\n    return snapshot.nodes.getValue(this.nodeIndex + snapshot.nodeIdOffset);\n  }\n\n  override isHidden(): boolean {\n    return this.rawType() === this.snapshot.nodeHiddenType;\n  }\n\n  override isArray(): boolean {\n    return this.rawType() === this.snapshot.nodeArrayType;\n  }\n\n  override isSynthetic(): boolean {\n    return this.rawType() === this.snapshot.nodeSyntheticType;\n  }\n\n  isNative(): boolean {\n    return this.rawType() === this.snapshot.nodeNativeType;\n  }\n\n  override isUserRoot(): boolean {\n    return !this.isSynthetic();\n  }\n\n  override isDocumentDOMTreesRoot(): boolean {\n    return this.isSynthetic() && this.rawName() === '(Document DOM trees)';\n  }\n\n  override serialize(): HeapSnapshotModel.HeapSnapshotModel.Node {\n    const result = super.serialize();\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    const flags = snapshot.flagsOfNode(this);\n    if (flags & snapshot.nodeFlags.canBeQueried) {\n      result.canBeQueried = true;\n    }\n    if (flags & snapshot.nodeFlags.detachedDOMTreeNode) {\n      result.detachedDOMTreeNode = true;\n    }\n    return result;\n  }\n}\n\nexport class JSHeapSnapshotEdge extends HeapSnapshotEdge {\n  override clone(): JSHeapSnapshotEdge {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    return new JSHeapSnapshotEdge(snapshot, this.edgeIndex);\n  }\n\n  override hasStringName(): boolean {\n    if (!this.isShortcut()) {\n      return this.hasStringNameInternal();\n    }\n    // @ts-expect-error parseInt is successful against numbers.\n    return isNaN(parseInt(this.nameInternal(), 10));\n  }\n\n  isElement(): boolean {\n    return this.rawType() === this.snapshot.edgeElementType;\n  }\n\n  isHidden(): boolean {\n    return this.rawType() === this.snapshot.edgeHiddenType;\n  }\n\n  override isWeak(): boolean {\n    return this.rawType() === this.snapshot.edgeWeakType;\n  }\n\n  override isInternal(): boolean {\n    return this.rawType() === this.snapshot.edgeInternalType;\n  }\n\n  override isInvisible(): boolean {\n    return this.rawType() === this.snapshot.edgeInvisibleType;\n  }\n\n  isShortcut(): boolean {\n    return this.rawType() === this.snapshot.edgeShortcutType;\n  }\n\n  override name(): string {\n    const name = this.nameInternal();\n    if (!this.isShortcut()) {\n      return String(name);\n    }\n    // @ts-expect-error parseInt is successful against numbers.\n    const numName = parseInt(name, 10);\n    return String(isNaN(numName) ? name : numName);\n  }\n\n  override toString(): string {\n    const name = this.name();\n    switch (this.type()) {\n      case 'context':\n        return '->' + name;\n      case 'element':\n        return '[' + name + ']';\n      case 'weak':\n        return '[[' + name + ']]';\n      case 'property':\n        return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n      case 'shortcut':\n        if (typeof name === 'string') {\n          return name.indexOf(' ') === -1 ? '.' + name : '[\"' + name + '\"]';\n        }\n        return '[' + name + ']';\n      case 'internal':\n      case 'hidden':\n      case 'invisible':\n        return '{' + name + '}';\n    }\n    return '?' + name + '?';\n  }\n\n  private hasStringNameInternal(): boolean {\n    const type = this.rawType();\n    const snapshot = this.snapshot;\n    return type !== snapshot.edgeElementType && type !== snapshot.edgeHiddenType;\n  }\n\n  private nameInternal(): string|number {\n    return this.hasStringNameInternal() ? this.snapshot.strings[this.nameOrIndex()] : this.nameOrIndex();\n  }\n\n  private nameOrIndex(): number {\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeNameOffset);\n  }\n\n  override rawType(): number {\n    return this.edges.getValue(this.edgeIndex + this.snapshot.edgeTypeOffset);\n  }\n\n  override nameIndex(): number {\n    if (!this.hasStringNameInternal()) {\n      throw new Error('Edge does not have string name');\n    }\n    return this.nameOrIndex();\n  }\n}\n\nexport class JSHeapSnapshotRetainerEdge extends HeapSnapshotRetainerEdge {\n  override clone(): JSHeapSnapshotRetainerEdge {\n    const snapshot = (this.snapshot as JSHeapSnapshot);\n    return new JSHeapSnapshotRetainerEdge(snapshot, this.retainerIndex());\n  }\n\n  isHidden(): boolean {\n    return this.edge().isHidden();\n  }\n\n  isInvisible(): boolean {\n    return this.edge().isInvisible();\n  }\n\n  isShortcut(): boolean {\n    return this.edge().isShortcut();\n  }\n\n  isWeak(): boolean {\n    return this.edge().isWeak();\n  }\n}\nexport interface AggregatedInfo {\n  count: number;\n  distance: number;\n  self: number;\n  maxRet: number;\n  name: string;\n  idxs: number[];\n}\n","/*\n * Copyright (C) 2013 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Platform from '../../core/platform/platform.js';\n\nimport {ContentData, type ContentDataOrError} from './ContentData.js';\nimport {SearchMatch} from './ContentProvider.js';\nimport type {Text} from './Text.js';\n\nconst KEY_VALUE_FILTER_REGEXP = /(?:^|\\s)(\\-)?([\\w\\-]+):([^\\s]+)/;\nconst REGEXP_FILTER_REGEXP = /(?:^|\\s)(\\-)?\\/([^\\/\\\\]+(\\\\.[^\\/]*)*)\\//;\nconst TEXT_FILTER_REGEXP = /(?:^|\\s)(\\-)?([^\\s]+)/;\nconst SPACE_CHAR_REGEXP = /\\s/;\n\nexport const Utils = {\n  isSpaceChar: function(char: string): boolean {\n    return SPACE_CHAR_REGEXP.test(char);\n  },\n\n  lineIndent: function(line: string): string {\n    let indentation = 0;\n    while (indentation < line.length && Utils.isSpaceChar(line.charAt(indentation))) {\n      ++indentation;\n    }\n    return line.substr(0, indentation);\n  },\n\n  splitStringByRegexes(text: string, regexes: RegExp[]): Array<{\n    value: string,\n    position: number,\n    regexIndex: number,\n    captureGroups: Array<string|undefined>,\n  }> {\n    const matches: Array<{\n      value: string,\n      position: number,\n      regexIndex: number,\n      captureGroups: Array<string|undefined>,\n    }> = [];\n    const globalRegexes: RegExp[] = [];\n    for (let i = 0; i < regexes.length; i++) {\n      const regex = regexes[i];\n      if (!regex.global) {\n        globalRegexes.push(new RegExp(regex.source, regex.flags ? regex.flags + 'g' : 'g'));\n      } else {\n        globalRegexes.push(regex);\n      }\n    }\n    doSplit(text, 0, 0);\n    return matches;\n\n    function doSplit(text: string, regexIndex: number, startIndex: number): void {\n      if (regexIndex >= globalRegexes.length) {\n        // Set regexIndex as -1 if text did not match with any regular expression\n        matches.push({value: text, position: startIndex, regexIndex: -1, captureGroups: []});\n        return;\n      }\n      const regex = globalRegexes[regexIndex];\n      let currentIndex = 0;\n      let result;\n      regex.lastIndex = 0;\n      while ((result = regex.exec(text)) !== null) {\n        const stringBeforeMatch = text.substring(currentIndex, result.index);\n        if (stringBeforeMatch) {\n          doSplit(stringBeforeMatch, regexIndex + 1, startIndex + currentIndex);\n        }\n        const match = result[0];\n        matches.push({\n          value: match,\n          position: startIndex + result.index,\n          regexIndex,\n          captureGroups: result.slice(1),\n        });\n        currentIndex = result.index + match.length;\n      }\n      const stringAfterMatches = text.substring(currentIndex);\n      if (stringAfterMatches) {\n        doSplit(stringAfterMatches, regexIndex + 1, startIndex + currentIndex);\n      }\n    }\n  },\n};\n\nexport class FilterParser {\n  private readonly keys: string[];\n  constructor(keys: string[]) {\n    this.keys = keys;\n  }\n\n  static cloneFilter(filter: ParsedFilter): ParsedFilter {\n    return {key: filter.key, text: filter.text, regex: filter.regex, negative: filter.negative};\n  }\n\n  parse(query: string): ParsedFilter[] {\n    const splitFilters =\n        Utils.splitStringByRegexes(query, [KEY_VALUE_FILTER_REGEXP, REGEXP_FILTER_REGEXP, TEXT_FILTER_REGEXP]);\n    const parsedFilters: ParsedFilter[] = [];\n    for (const {regexIndex, captureGroups} of splitFilters) {\n      if (regexIndex === -1) {\n        continue;\n      }\n      if (regexIndex === 0) {\n        const startsWithMinus = captureGroups[0];\n        const parsedKey = captureGroups[1];\n        const parsedValue = captureGroups[2];\n        if (this.keys.indexOf((parsedKey as string)) !== -1) {\n          parsedFilters.push({\n            key: parsedKey,\n            regex: undefined,\n            text: parsedValue,\n            negative: Boolean(startsWithMinus),\n          });\n        } else {\n          parsedFilters.push({\n            key: undefined,\n            regex: undefined,\n            text: `${parsedKey}:${parsedValue}`,\n            negative: Boolean(startsWithMinus),\n          });\n        }\n      } else if (regexIndex === 1) {\n        const startsWithMinus = captureGroups[0];\n        const parsedRegex = captureGroups[1];\n        try {\n          parsedFilters.push({\n            key: undefined,\n            regex: new RegExp((parsedRegex as string), 'im'),\n            text: undefined,\n            negative: Boolean(startsWithMinus),\n          });\n        } catch {\n          parsedFilters.push({\n            key: undefined,\n            regex: undefined,\n            text: `/${parsedRegex}/`,\n            negative: Boolean(startsWithMinus),\n          });\n        }\n      } else if (regexIndex === 2) {\n        const startsWithMinus = captureGroups[0];\n        const parsedText = captureGroups[1];\n        parsedFilters.push({\n          key: undefined,\n          regex: undefined,\n          text: parsedText,\n          negative: Boolean(startsWithMinus),\n        });\n      }\n    }\n    return parsedFilters;\n  }\n}\n\nexport class BalancedJSONTokenizer {\n  private readonly callback: (arg0: string) => void;\n  private index: number;\n  private balance: number;\n  private buffer: string;\n  private findMultiple: boolean;\n  private closingDoubleQuoteRegex: RegExp;\n  private lastBalancedIndex?: number;\n  constructor(callback: (arg0: string) => void, findMultiple?: boolean) {\n    this.callback = callback;\n    this.index = 0;\n    this.balance = 0;\n    this.buffer = '';\n    this.findMultiple = findMultiple || false;\n    this.closingDoubleQuoteRegex = /[^\\\\](?:\\\\\\\\)*\"/g;\n  }\n\n  write(chunk: string): boolean {\n    this.buffer += chunk;\n    const lastIndex = this.buffer.length;\n    const buffer = this.buffer;\n    let index;\n    for (index = this.index; index < lastIndex; ++index) {\n      const character = buffer[index];\n      if (character === '\"') {\n        this.closingDoubleQuoteRegex.lastIndex = index;\n        if (!this.closingDoubleQuoteRegex.test(buffer)) {\n          break;\n        }\n        index = this.closingDoubleQuoteRegex.lastIndex - 1;\n      } else if (character === '{') {\n        ++this.balance;\n      } else if (character === '}') {\n        --this.balance;\n        if (this.balance < 0) {\n          this.reportBalanced();\n          return false;\n        }\n        if (!this.balance) {\n          this.lastBalancedIndex = index + 1;\n          if (!this.findMultiple) {\n            break;\n          }\n        }\n      } else if (character === ']' && !this.balance) {\n        this.reportBalanced();\n        return false;\n      }\n    }\n    this.index = index;\n    this.reportBalanced();\n    return true;\n  }\n\n  private reportBalanced(): void {\n    if (!this.lastBalancedIndex) {\n      return;\n    }\n    this.callback(this.buffer.slice(0, this.lastBalancedIndex));\n    this.buffer = this.buffer.slice(this.lastBalancedIndex);\n    this.index -= this.lastBalancedIndex;\n    this.lastBalancedIndex = 0;\n  }\n\n  remainder(): string {\n    return this.buffer;\n  }\n}\n\n/**\n * Detects the indentation used by a given text document, based on the _Comparing\n * lines_ approach suggested by Heather Arthur (and also found in Firefox DevTools).\n *\n * This implementation differs from the original proposal in that tab indentation\n * isn't detected by checking if at least 50% of the lines start with a tab, but\n * instead by comparing the number of lines that start with a tab to the frequency\n * of the other indentation patterns. This way we also detect small snippets with\n * long leading comments correctly, when tab indentation is used for the snippets\n * of code.\n *\n * @param lines The input document lines.\n * @return The indentation detected for the lines as string or `null` if it's inconclusive.\n *\n * @see https://heathermoor.medium.com/detecting-code-indentation-eff3ed0fb56b\n */\nexport const detectIndentation = function(lines: Iterable<string>): string|null {\n  const frequencies: number[] = [0, 0, 0, 0, 0, 0, 0, 0, 0];\n  let tabs = 0, previous = 0;\n\n  for (const line of lines) {\n    let current = 0;\n    if (line.length !== 0) {\n      let char = line.charAt(0);\n      if (char === '\\t') {\n        tabs++;\n        continue;\n      }\n      while (char === ' ') {\n        char = line.charAt(++current);\n      }\n    }\n\n    if (current === line.length) {\n      // Don't consider empty lines.\n      previous = 0;\n      continue;\n    }\n\n    const delta = Math.abs(current - previous);\n    if (delta < frequencies.length) {\n      // Don't consider deltas above 8 characters.\n      frequencies[delta] = frequencies[delta] + 1;\n    }\n    previous = current;\n  }\n\n  // Find most frequent non-zero width difference between adjacent lines.\n  let mostFrequentDelta = 0, highestFrequency = 0;\n  for (let delta = 1; delta < frequencies.length; ++delta) {\n    const frequency = frequencies[delta];\n    if (frequency > highestFrequency) {\n      highestFrequency = frequency;\n      mostFrequentDelta = delta;\n    }\n  }\n\n  if (tabs > mostFrequentDelta) {\n    // If more lines start with tabs than any other indentation,\n    // we assume that the document was written with tab indentation\n    // in mind. This differs from the original algorithm.\n    return '\\t';\n  }\n\n  if (!mostFrequentDelta) {\n    return null;\n  }\n\n  return ' '.repeat(mostFrequentDelta);\n};\n\n/**\n * Heuristic to check whether a given text was likely minified. Intended to\n * be used for HTML, CSS, and JavaScript inputs.\n *\n * A text is considered to be the result of minification if the average\n * line length for the whole text is 80 characters or more.\n *\n * @param text The input text to check.\n * @returns\n */\nexport const isMinified = function(text: string): boolean {\n  let lineCount = 0;\n  for (let lastIndex = 0; lastIndex < text.length; ++lineCount) {\n    let eolIndex = text.indexOf('\\n', lastIndex);\n    if (eolIndex < 0) {\n      eolIndex = text.length;\n    }\n    lastIndex = eolIndex + 1;\n  }\n  return (text.length - lineCount) / lineCount >= 80;\n};\n\n/**\n * Small wrapper around {@link performSearchInContent} to reduce boilerplate when searching\n * in {@link ContentDataOrError}.\n *\n * @returns empty search matches if `contentData` is an error or not text content.\n */\nexport const performSearchInContentData = function(\n    contentData: ContentDataOrError, query: string, caseSensitive: boolean, isRegex: boolean): SearchMatch[] {\n  if (ContentData.isError(contentData) || !contentData.isTextContent) {\n    return [];\n  }\n  return performSearchInContent(contentData.textObj, query, caseSensitive, isRegex);\n};\n\n/**\n * @returns One {@link SearchMatch} per match. Multiple matches on the same line each\n * result in their own `SearchMatchExact` instance.\n */\nexport const performSearchInContent = function(\n    text: Text, query: string, caseSensitive: boolean, isRegex: boolean): SearchMatch[] {\n  const regex = Platform.StringUtilities.createSearchRegex(query, caseSensitive, isRegex);\n\n  const result = [];\n  for (let i = 0; i < text.lineCount(); ++i) {\n    const lineContent = text.lineAt(i);\n    const matches = lineContent.matchAll(regex);\n    for (const match of matches) {\n      result.push(new SearchMatch(i, lineContent, match.index, match[0].length));\n    }\n  }\n  return result;\n};\n\n/**\n * Similar to {@link performSearchInContent} but doesn't search in a whole text but rather\n * finds the exact matches on a prelminiary search result (i.e. lines with known matches).\n * @param matches is deliberatedly typed as an object literal so we can pass the\n *                CDP search result type.\n */\nexport const performSearchInSearchMatches = function(\n    matches: Array<{lineNumber: number, lineContent: string}>, query: string, caseSensitive: boolean,\n    isRegex: boolean): SearchMatch[] {\n  const regex = Platform.StringUtilities.createSearchRegex(query, caseSensitive, isRegex);\n  const result = [];\n\n  for (const {lineNumber, lineContent} of matches) {\n    const matches = lineContent.matchAll(regex);\n    for (const match of matches) {\n      result.push(new SearchMatch(lineNumber, lineContent, match.index, match[0].length));\n    }\n  }\n  return result;\n};\n\nexport interface ParsedFilter {\n  key?: string;\n  text?: string|null;\n  regex?: RegExp;\n  negative: boolean;\n}\n","// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nexport const BASE64_CHARS = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\nexport const BASE64_CODES = new Uint8Array(123);\nfor (let index = 0; index < BASE64_CHARS.length; ++index) {\n  BASE64_CODES[BASE64_CHARS.charCodeAt(index)] = index;\n}\n\n/**\n * Decodes Base64-encoded data from a string without performing any kind of checking.\n */\nexport function decode(input: string): Uint8Array<ArrayBuffer> {\n  let bytesLength = ((input.length * 3) / 4) >>> 0;\n  if (input.charCodeAt(input.length - 2) === 0x3d /* '=' */) {\n    bytesLength -= 2;\n  } else if (input.charCodeAt(input.length - 1) === 0x3d /* '=' */) {\n    bytesLength -= 1;\n  }\n\n  const bytes = new Uint8Array(bytesLength);\n  for (let index = 0, offset = 0; index < input.length; index += 4) {\n    const a = BASE64_CODES[input.charCodeAt(index + 0)];\n    const b = BASE64_CODES[input.charCodeAt(index + 1)];\n    const c = BASE64_CODES[input.charCodeAt(index + 2)];\n    const d = BASE64_CODES[input.charCodeAt(index + 3)];\n    bytes[offset++] = (a << 2) | (b >> 4);\n    bytes[offset++] = ((b & 0x0f) << 4) | (c >> 2);\n    bytes[offset++] = ((c & 0x03) << 6) | (d & 0x3f);\n  }\n  return bytes;\n}\n\nexport function encode(input: BlobPart): Promise<string> {\n  return new Promise((resolve, reject) => {\n    const reader = new FileReader();\n    reader.onerror = () => reject(new Error('failed to convert to base64'));\n    reader.onload = () => {\n      const blobAsUrl = reader.result as string;\n      const [, base64] = blobAsUrl.split(',', 2);\n      resolve(base64);\n    };\n\n    reader.readAsDataURL(new Blob([input]));\n  });\n}\n","// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../i18n/i18n.js';\nimport type * as Platform from '../platform/platform.js';\n\nconst UIStrings = {\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  elementsPanel: 'Elements panel',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  stylesSidebar: 'styles sidebar',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  changesDrawer: 'Changes drawer',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  issuesView: 'Issues view',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  networkPanel: 'Network panel',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  applicationPanel: 'Application panel',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  securityPanel: 'Security panel',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  sourcesPanel: 'Sources panel',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  timelinePanel: 'Performance panel',\n  /**\n   *@description The UI destination when right clicking an item that can be revealed\n   */\n  memoryInspectorPanel: 'Memory inspector panel',\n  /**\n   * @description The UI destination when revealing loaded resources through the Developer Resources Panel\n   */\n  developerResourcesPanel: 'Developer Resources panel',\n  /**\n   * @description The UI destination when revealing loaded resources through the Animations panel\n   */\n  animationsPanel: 'Animations panel',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('core/common/Revealer.ts', UIStrings);\nconst i18nLazyString = i18n.i18n.getLazilyComputedLocalizedString.bind(undefined, str_);\n\n/**\n * Interface for global revealers, which are entities responsible for\n * dealing with revealing certain types of objects. For example, the\n * Sources panel will register a revealer for `UISourceCode` objects,\n * which will ensure that its visible in an editor tab.\n */\nexport interface Revealer<T> {\n  reveal(revealable: T, omitFocus?: boolean): Promise<void>;\n}\n\nlet revealerRegistry: RevealerRegistry|undefined;\n\n/**\n * Registration for revealers, which deals with keeping a list of all possible\n * revealers, lazily instantiating them as necessary and invoking their `reveal`\n * methods depending on the _context types_ they were registered for.\n *\n * @see Revealer\n */\nexport class RevealerRegistry {\n  private readonly registeredRevealers: Array<RevealerRegistration<unknown>> = [];\n\n  /**\n   * Yields the singleton instance, creating it on-demand when necessary.\n   *\n   * @returns the singleton instance.\n   */\n  static instance(): RevealerRegistry {\n    if (revealerRegistry === undefined) {\n      revealerRegistry = new RevealerRegistry();\n    }\n    return revealerRegistry;\n  }\n\n  /**\n   * Clears the singleton instance (if any).\n   */\n  static removeInstance(): void {\n    revealerRegistry = undefined;\n  }\n\n  /**\n   * Register a new `Revealer` as described by the `registration`.\n   *\n   * @param registration the description.\n   */\n  register(registration: RevealerRegistration<unknown>): void {\n    this.registeredRevealers.push(registration);\n  }\n\n  /**\n   * Reveals the `revealable`.\n   *\n   * @param revealable the object to reveal.\n   * @param omitFocus whether to omit focusing on the presentation of `revealable` afterwards.\n   */\n  async reveal(revealable: unknown, omitFocus: boolean): Promise<void> {\n    const revealers = await Promise.all(\n        this.getApplicableRegisteredRevealers(revealable).map(registration => registration.loadRevealer()));\n    if (revealers.length < 1) {\n      throw new Error(`No revealers found for ${revealable}`);\n    }\n    if (revealers.length > 1) {\n      throw new Error(`Conflicting reveals found for ${revealable}`);\n    }\n    return await revealers[0].reveal(revealable, omitFocus);\n  }\n\n  getApplicableRegisteredRevealers(revealable: unknown): Array<RevealerRegistration<unknown>> {\n    return this.registeredRevealers.filter(registration => {\n      for (const contextType of registration.contextTypes()) {\n        if (revealable instanceof contextType) {\n          return true;\n        }\n      }\n      return false;\n    });\n  }\n}\n\nexport function revealDestination(revealable: unknown): string|null {\n  const revealers = RevealerRegistry.instance().getApplicableRegisteredRevealers(revealable);\n  for (const {destination} of revealers) {\n    if (destination) {\n      return destination();\n    }\n  }\n  return null;\n}\n\n/**\n * Register a new `Revealer` as described by the `registration` on the singleton\n * {@link RevealerRegistry} instance.\n *\n * @param registration the description.\n */\nexport function registerRevealer<T>(registration: RevealerRegistration<T>): void {\n  RevealerRegistry.instance().register(registration);\n}\n\n/**\n * Reveals the `revealable` via the singleton {@link RevealerRegistry} instance.\n *\n * @param revealable the object to reveal.\n * @param omitFocus whether to omit focusing on the presentation of `revealable` afterwards.\n */\nexport async function reveal(revealable: unknown, omitFocus = false): Promise<void> {\n  await RevealerRegistry.instance().reveal(revealable, omitFocus);\n}\n\nexport interface RevealerRegistration<T> {\n  contextTypes: () => Array<abstract new(...any: any[]) => T>;\n  loadRevealer: () => Promise<Revealer<T>>;\n  destination?: RevealerDestination;\n}\n\nexport const RevealerDestination = {\n  DEVELOPER_RESOURCES_PANEL: i18nLazyString(UIStrings.developerResourcesPanel),\n  ELEMENTS_PANEL: i18nLazyString(UIStrings.elementsPanel),\n  STYLES_SIDEBAR: i18nLazyString(UIStrings.stylesSidebar),\n  CHANGES_DRAWER: i18nLazyString(UIStrings.changesDrawer),\n  ISSUES_VIEW: i18nLazyString(UIStrings.issuesView),\n  NETWORK_PANEL: i18nLazyString(UIStrings.networkPanel),\n  TIMELINE_PANEL: i18nLazyString(UIStrings.timelinePanel),\n  APPLICATION_PANEL: i18nLazyString(UIStrings.applicationPanel),\n  SOURCES_PANEL: i18nLazyString(UIStrings.sourcesPanel),\n  SECURITY_PANEL: i18nLazyString(UIStrings.securityPanel),\n  MEMORY_INSPECTOR_PANEL: i18nLazyString(UIStrings.memoryInspectorPanel),\n  ANIMATIONS_PANEL: i18nLazyString(UIStrings.animationsPanel),\n};\n\nexport type RevealerDestination = () => Platform.UIString.LocalizedString;\n","// Copyright 2014 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport {ObjectWrapper} from './Object.js';\nimport {reveal} from './Revealer.js';\n\nlet consoleInstance: Console|undefined;\n\nexport class Console extends ObjectWrapper<EventTypes> {\n  readonly #messagesInternal: Message[];\n  /**\n   * Instantiable via the instance() factory below.\n   */\n  constructor() {\n    super();\n    this.#messagesInternal = [];\n  }\n\n  static instance(opts?: {forceNew: boolean}): Console {\n    if (!consoleInstance || opts?.forceNew) {\n      consoleInstance = new Console();\n    }\n\n    return consoleInstance;\n  }\n\n  static removeInstance(): void {\n    consoleInstance = undefined;\n  }\n\n  /**\n   * Add a message to the Console panel.\n   *\n   * @param text the message text.\n   * @param level the message level.\n   * @param show whether to show the Console panel (if it's not already shown).\n   * @param source the message source.\n   */\n  addMessage(text: string, level = MessageLevel.INFO, show = false, source?: FrontendMessageSource): void {\n    const message = new Message(text, level, Date.now(), show, source);\n    this.#messagesInternal.push(message);\n    this.dispatchEventToListeners(Events.MESSAGE_ADDED, message);\n  }\n\n  log(text: string): void {\n    this.addMessage(text, MessageLevel.INFO);\n  }\n\n  warn(text: string, source?: FrontendMessageSource): void {\n    this.addMessage(text, MessageLevel.WARNING, undefined, source);\n  }\n\n  /**\n   * Adds an error message to the Console panel.\n   *\n   * @param text the message text.\n   * @param show whether to show the Console panel (if it's not already shown).\n   */\n  error(text: string, show = true): void {\n    this.addMessage(text, MessageLevel.ERROR, show);\n  }\n\n  messages(): Message[] {\n    return this.#messagesInternal;\n  }\n\n  show(): void {\n    void this.showPromise();\n  }\n\n  showPromise(): Promise<void> {\n    return reveal(this);\n  }\n}\n\nexport const enum Events {\n  MESSAGE_ADDED = 'messageAdded',\n}\n\nexport interface EventTypes {\n  [Events.MESSAGE_ADDED]: Message;\n}\n\nexport const enum MessageLevel {\n  INFO = 'info',\n  WARNING = 'warning',\n  ERROR = 'error',\n}\n\nexport enum FrontendMessageSource {\n  CSS = 'css',\n  // eslint-disable-next-line @typescript-eslint/naming-convention -- Used by web_tests.\n  ConsoleAPI = 'console-api',\n  ISSUE_PANEL = 'issue-panel',\n  SELF_XSS = 'self-xss',\n}\n\nexport class Message {\n  text: string;\n  level: MessageLevel;\n  timestamp: number;\n  show: boolean;\n  source?: FrontendMessageSource;\n  constructor(text: string, level: MessageLevel, timestamp: number, show: boolean, source?: FrontendMessageSource) {\n    this.text = text;\n    this.level = level;\n    this.timestamp = (typeof timestamp === 'number') ? timestamp : Date.now();\n    this.show = show;\n    if (source) {\n      this.source = source;\n    }\n  }\n}\n","// Copyright 2020 The Chromium Authors. All rights reserved.\n// Use of this source code is governed by a BSD-style license that can be\n// found in the LICENSE file.\n\nimport * as i18n from '../i18n/i18n.js';\nimport type * as Platform from '../platform/platform.js';\nimport * as Root from '../root/root.js';\n\nimport type {SettingStorageType} from './Settings.js';\n\nconst UIStrings = {\n  /**\n   *@description Title of the Elements Panel\n   */\n  elements: 'Elements',\n  /**\n   *@description Text for DevTools AI\n   */\n  ai: 'AI',\n  /**\n   *@description Text for DevTools appearance\n   */\n  appearance: 'Appearance',\n  /**\n   *@description Name of the Sources panel\n   */\n  sources: 'Sources',\n  /**\n   *@description Title of the Network tool\n   */\n  network: 'Network',\n  /**\n   *@description Text for the performance of something\n   */\n  performance: 'Performance',\n  /**\n   *@description Title of the Console tool\n   */\n  console: 'Console',\n  /**\n   *@description A title of the 'Persistence' setting category\n   */\n  persistence: 'Persistence',\n  /**\n   *@description Text that refers to the debugger\n   */\n  debugger: 'Debugger',\n  /**\n   *@description Text describing global shortcuts and settings that are available throughout the DevTools\n   */\n  global: 'Global',\n  /**\n   *@description Title of the Rendering tool\n   */\n  rendering: 'Rendering',\n  /**\n   *@description Title of a section on CSS Grid tooling\n   */\n  grid: 'Grid',\n  /**\n   *@description Text for the mobile platform, as opposed to desktop\n   */\n  mobile: 'Mobile',\n  /**\n   *@description Text for the memory of the page\n   */\n  memory: 'Memory',\n  /**\n   *@description Text for the extension of the page\n   */\n  extension: 'Extension',\n  /**\n   *@description Text for the adorner of the page\n   */\n  adorner: 'Adorner',\n  /**\n   * @description Header for the \"Sync\" section in the settings UI. The \"Sync\"\n   * section allows users to configure which DevTools data is synced via Chrome Sync.\n   */\n  sync: 'Sync',\n  /**\n   * @description Text for the privacy section of the page.\n   */\n  privacy: 'Privacy',\n} as const;\nconst str_ = i18n.i18n.registerUIStrings('core/common/SettingRegistration.ts', UIStrings);\nconst i18nString = i18n.i18n.getLocalizedString.bind(undefined, str_);\nlet registeredSettings: SettingRegistration[] = [];\nconst settingNameSet = new Set<string>();\n\nexport function registerSettingExtension(registration: SettingRegistration): void {\n  const settingName = registration.settingName;\n  if (settingNameSet.has(settingName)) {\n    throw new Error(`Duplicate setting name '${settingName}'`);\n  }\n  settingNameSet.add(settingName);\n  registeredSettings.push(registration);\n}\n\nexport function getRegisteredSettings(): SettingRegistration[] {\n  return registeredSettings.filter(setting => Root.Runtime.Runtime.isDescriptorEnabled(setting));\n}\n\nexport function registerSettingsForTest(settings: SettingRegistration[], forceReset = false): void {\n  if (registeredSettings.length === 0 || forceReset) {\n    registeredSettings = settings;\n    settingNameSet.clear();\n    for (const setting of settings) {\n      const settingName = setting.settingName;\n      if (settingNameSet.has(settingName)) {\n        throw new Error(`Duplicate setting name '${settingName}'`);\n      }\n      settingNameSet.add(settingName);\n    }\n  }\n}\n\nexport function resetSettings(): void {\n  registeredSettings = [];\n  settingNameSet.clear();\n}\n\nexport function maybeRemoveSettingExtension(settingName: string): boolean {\n  const settingIndex = registeredSettings.findIndex(setting => setting.settingName === settingName);\n  if (settingIndex < 0 || !settingNameSet.delete(settingName)) {\n    return false;\n  }\n  registeredSettings.splice(settingIndex, 1);\n  return true;\n}\n\nexport const enum SettingCategory {\n  NONE = '',  // `NONE` must be a falsy value. Legacy code uses if-checks for the category.\n  ELEMENTS = 'ELEMENTS',\n  AI = 'AI',\n  APPEARANCE = 'APPEARANCE',\n  SOURCES = 'SOURCES',\n  NETWORK = 'NETWORK',\n  PERFORMANCE = 'PERFORMANCE',\n  CONSOLE = 'CONSOLE',\n  PERSISTENCE = 'PERSISTENCE',\n  DEBUGGER = 'DEBUGGER',\n  GLOBAL = 'GLOBAL',\n  RENDERING = 'RENDERING',\n  GRID = 'GRID',\n  MOBILE = 'MOBILE',\n  EMULATION = 'EMULATION',\n  MEMORY = 'MEMORY',\n  EXTENSIONS = 'EXTENSIONS',\n  ADORNER = 'ADORNER',\n  SYNC = 'SYNC',\n  PRIVACY = 'PRIVACY',\n}\n\nexport function getLocalizedSettingsCategory(category: SettingCategory): Platform.UIString.LocalizedString {\n  switch (category) {\n    case SettingCategory.ELEMENTS:\n      return i18nString(UIStrings.elements);\n    case SettingCategory.AI:\n      return i18nString(UIStrings.ai);\n    case SettingCategory.APPEARANCE:\n      return i18nString(UIStrings.appearance);\n    case SettingCategory.SOURCES:\n      return i18nString(UIStrings.sources);\n    case SettingCategory.NETWORK:\n      return i18nString(UIStrings.network);\n    case SettingCategory.PERFORMANCE:\n      return i18nString(UIStrings.performance);\n    case SettingCategory.CONSOLE:\n      return i18nString(UIStrings.console);\n    case SettingCategory.PERSISTENCE:\n      return i18nString(UIStrings.persistence);\n    case SettingCategory.DEBUGGER:\n      return i18nString(UIStrings.debugger);\n    case SettingCategory.GLOBAL:\n      return i18nString(UIStrings.global);\n    case SettingCategory.RENDERING:\n      return i18nString(UIStrings.rendering);\n    case SettingCategory.GRID:\n      return i18nString(UIStrings.grid);\n    case SettingCategory.MOBILE:\n      return i18nString(UIStrings.mobile);\n    case SettingCategory.EMULATION:\n      return i18nString(UIStrings.console);\n    case SettingCategory.MEMORY:\n      return i18nString(UIStrings.memory);\n    case SettingCategory.EXTENSIONS:\n      return i18nString(UIStrings.extension);\n    case SettingCategory.ADORNER:\n      return i18nString(UIStrings.adorner);\n    case SettingCategory.NONE:\n      return i18n.i18n.lockedString('');\n    case SettingCategory.SYNC:\n      return i18nString(UIStrings.sync);\n    case SettingCategory.PRIVACY:\n      return i18nString(UIStrings.privacy);\n  }\n}\n\nexport const enum SettingType {\n  ARRAY = 'array',\n  REGEX = 'regex',\n  ENUM = 'enum',\n  BOOLEAN = 'boolean',\n}\n\nexport interface RegExpSettingItem {\n  /**\n   * A regular expression matched against URLs for ignore listing.\n   */\n  pattern: string;\n  /**\n   * If true, ignore this rule.\n   */\n  disabled?: boolean;\n  /**\n   * When a rule is disabled due to requesting through a script's context menu\n   * that it no longer be ignore listed, this field is set to the URL of that\n   * script, so that if the user requests through the same context menu to\n   * enable ignore listing, the rule can be reenabled.\n   */\n  disabledForUrl?: Platform.DevToolsPath.UrlString;\n}\n\nexport interface SettingRegistration {\n  /**\n   * The category with which the setting is displayed in the UI.\n   */\n  category?: SettingCategory;\n  /**\n   * Used to sort on screen the settings that belong to the same category.\n   */\n  order?: number;\n  /**\n   * The title with which the setting is shown on screen.\n   */\n  title?: () => Platform.UIString.LocalizedString;\n  /**\n   * The identifier of the setting.\n   */\n  settingName: string;\n  /**\n   * Determines how the possible values of the setting are expressed.\n   *\n   * - If the setting can only be enabled and disabled use BOOLEAN\n   * - If the setting has a list of possible values use ENUM\n   * - If each setting value is a set of objects use ARRAY\n   * - If the setting value is a regular expression use REGEX\n   */\n  settingType: SettingType;\n  /**\n   * The value set by default to the setting.\n   */\n  defaultValue: unknown;\n  /**\n   * Words used to find a setting in the Command Menu.\n   */\n  tags?: Array<() => Platform.UIString.LocalizedString>;\n  /**\n   * The possible values the setting can have, each with a description composed of a title and an optional text.\n   */\n  options?: SettingExtensionOption[];\n  /**\n   * Whether DevTools must be reloaded for a change in the setting to take effect.\n   */\n  reloadRequired?: boolean;\n  /**\n   * Determines if the setting value is stored in the global, local or session storage.\n   */\n  storageType?: SettingStorageType;\n  /**\n   * A condition that, when present in the queryParamsObject of Runtime, constraints the value\n   * of the setting to be changed only if the user set it.\n   */\n  userActionCondition?: string;\n  /**\n   * The name of the experiment a setting is associated with. Enabling and disabling the declared\n   * experiment will enable and disable the setting respectively.\n   */\n  experiment?: Root.Runtime.ExperimentName;\n  /**\n   * A condition is a function that will make the setting available if it\n   * returns true, and not available, otherwise. Make sure that objects you\n   * access from inside the condition function are ready at the time when the\n   * setting conditions are checked.\n   */\n  condition?: Root.Runtime.Condition;\n\n  /**\n   * A function that returns true if the setting should be disabled, along with\n   * the reason why.\n   */\n  disabledCondition?: (config?: Root.Runtime.HostConfig) => DisabledConditionResult;\n\n  /**\n   * If a setting is deprecated, define this notice to show an appropriate warning according to the `warning` property.\n   * If `disabled` is set, the setting will be disabled in the settings UI. In that case, `experiment` optionally can be\n   * set to link to an experiment (by experiment name). The information icon in the settings UI can then be clicked to\n   * jump to the experiment. If a setting is not disabled, the experiment entry will be ignored.\n   */\n  deprecationNotice?: {disabled: boolean, warning: () => Platform.UIString.LocalizedString, experiment?: string};\n\n  /**\n   * Optional information to learn more about the setting. If provided, a `(?)` icon will show next to the setting\n   * in the Settings panel with a link to learn more, and the `tooltip` will be presented to the user when hovering\n   * the `(?)` icon.\n   */\n  learnMore?: LearnMore;\n}\n\n/**\n * Metadata to learn more about a setting. The `url` will be used to construct\n * a `(?)` icon link and the `tooltip` will be shown when hovering the icon.\n */\nexport interface LearnMore {\n  tooltip: () => Platform.UIString.LocalizedString;\n  url?: Platform.DevToolsPath.UrlString;\n}\n\ninterface LocalizedSettingExtensionOption {\n  value: boolean|string;\n  title: () => Platform.UIString.LocalizedString;\n  text?: () => Platform.UIString.LocalizedString;\n  raw?: false;\n}\ninterface RawSettingExtensionOption {\n  value: boolean|string;\n  title: () => Platform.UIString.LocalizedString;\n  /**\n   * Text used to describe the option. Must be localized if 'raw' is false.\n   */\n  text?: string;\n  raw: true;\n}\nexport type SettingExtensionOption = LocalizedSettingExtensionOption|RawSettingExtensionOption;\nexport type DisabledConditionResult = {\n  disabled: true,\n  reasons: Platform.UIString.LocalizedString[],\n}|{disabled: false};\n","/*\n * Copyright (C) 2012 Google Inc. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of Google Inc. nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport * as Platform from '../../core/platform/platform.js';\nimport * as TextUtils from '../../models/text_utils/text_utils.js';\n\nimport {type HeapSnapshotHeader, HeapSnapshotProgress, JSHeapSnapshot, type Profile} from './HeapSnapshot.js';\nimport type {HeapSnapshotWorkerDispatcher} from './HeapSnapshotWorkerDispatcher.js';\n\nexport class HeapSnapshotLoader {\n  readonly #progress: HeapSnapshotProgress;\n  #buffer: string[];\n  #dataCallback: ((value: string|PromiseLike<string>) => void)|null;\n  #done: boolean;\n  // TODO(crbug.com/1172300) Ignored during the jsdoc to ts migration)\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  #snapshot?: Record<string, any>;\n  #array!: Platform.TypedArrayUtilities.BigUint32Array|null;\n  #arrayIndex!: number;\n  #json = '';\n  parsingComplete: Promise<void>;\n  constructor(dispatcher: HeapSnapshotWorkerDispatcher) {\n    this.#reset();\n    this.#progress = new HeapSnapshotProgress(dispatcher);\n    this.#buffer = [];\n    this.#dataCallback = null;\n    this.#done = false;\n    this.parsingComplete = this.#parseInput();\n  }\n\n  dispose(): void {\n    this.#reset();\n  }\n\n  #reset(): void {\n    this.#json = '';\n    this.#snapshot = undefined;\n  }\n\n  close(): void {\n    this.#done = true;\n    if (this.#dataCallback) {\n      this.#dataCallback('');\n    }\n  }\n\n  async buildSnapshot(secondWorker: MessagePort): Promise<JSHeapSnapshot> {\n    this.#snapshot = this.#snapshot || {};\n\n    this.#progress.updateStatus('Processing snapshot');\n    const result = new JSHeapSnapshot((this.#snapshot as Profile), this.#progress);\n    await result.initialize(secondWorker);\n    this.#reset();\n    return result;\n  }\n\n  #parseUintArray(): boolean {\n    let index = 0;\n    const char0 = '0'.charCodeAt(0);\n    const char9 = '9'.charCodeAt(0);\n    const closingBracket = ']'.charCodeAt(0);\n    const length = this.#json.length;\n    while (true) {\n      while (index < length) {\n        const code = this.#json.charCodeAt(index);\n        if (char0 <= code && code <= char9) {\n          break;\n        } else if (code === closingBracket) {\n          this.#json = this.#json.slice(index + 1);\n          return false;\n        }\n        ++index;\n      }\n      if (index === length) {\n        this.#json = '';\n        return true;\n      }\n      let nextNumber = 0;\n      const startIndex = index;\n      while (index < length) {\n        const code = this.#json.charCodeAt(index);\n        if (char0 > code || code > char9) {\n          break;\n        }\n        nextNumber *= 10;\n        nextNumber += (code - char0);\n        ++index;\n      }\n      if (index === length) {\n        this.#json = this.#json.slice(startIndex);\n        return true;\n      }\n      if (!this.#array) {\n        throw new Error('Array not instantiated');\n      }\n      this.#array.setValue(this.#arrayIndex++, nextNumber);\n    }\n  }\n\n  #parseStringsArray(): void {\n    this.#progress.updateStatus('Parsing strings');\n    const closingBracketIndex = this.#json.lastIndexOf(']');\n    if (closingBracketIndex === -1) {\n      throw new Error('Incomplete JSON');\n    }\n    this.#json = this.#json.slice(0, closingBracketIndex + 1);\n\n    if (!this.#snapshot) {\n      throw new Error('No snapshot in parseStringsArray');\n    }\n    this.#snapshot.strings = JSON.parse(this.#json);\n  }\n\n  write(chunk: string): void {\n    this.#buffer.push(chunk);\n    if (!this.#dataCallback) {\n      return;\n    }\n    this.#dataCallback(this.#buffer.shift() as string);\n    this.#dataCallback = null;\n  }\n\n  #fetchChunk(): Promise<string> {\n    // This method shoudln't be entered more than once since parsing happens\n    // sequentially. This means it's fine to stash away a single #dataCallback\n    // instead of an array of them.\n    if (this.#buffer.length > 0) {\n      return Promise.resolve(this.#buffer.shift() as string);\n    }\n\n    const {promise, resolve} = Promise.withResolvers<string>();\n    this.#dataCallback = resolve;\n    return promise;\n  }\n\n  async #findToken(token: string, startIndex?: number): Promise<number> {\n    while (true) {\n      const pos = this.#json.indexOf(token, startIndex || 0);\n      if (pos !== -1) {\n        return pos;\n      }\n      startIndex = this.#json.length - token.length + 1;\n      this.#json += await this.#fetchChunk();\n    }\n  }\n\n  async #parseArray(name: string, title: string, length?: number):\n      Promise<Platform.TypedArrayUtilities.BigUint32Array> {\n    const nameIndex = await this.#findToken(name);\n    const bracketIndex = await this.#findToken('[', nameIndex);\n    this.#json = this.#json.slice(bracketIndex + 1);\n    this.#array = length === undefined ? Platform.TypedArrayUtilities.createExpandableBigUint32Array() :\n                                         Platform.TypedArrayUtilities.createFixedBigUint32Array(length);\n    this.#arrayIndex = 0;\n    while (this.#parseUintArray()) {\n      if (length) {\n        this.#progress.updateProgress(title, this.#arrayIndex, this.#array.length);\n      } else {\n        this.#progress.updateStatus(title);\n      }\n      this.#json += await this.#fetchChunk();\n    }\n    const result = this.#array;\n    this.#array = null;\n    return result;\n  }\n\n  async #parseInput(): Promise<void> {\n    const snapshotToken = '\"snapshot\"';\n    const snapshotTokenIndex = await this.#findToken(snapshotToken);\n    if (snapshotTokenIndex === -1) {\n      throw new Error('Snapshot token not found');\n    }\n\n    this.#progress.updateStatus('Loading snapshot info');\n    const json = this.#json.slice(snapshotTokenIndex + snapshotToken.length + 1);\n    let jsonTokenizerDone = false;\n    const jsonTokenizer = new TextUtils.TextUtils.BalancedJSONTokenizer(metaJSON => {\n      this.#json = jsonTokenizer.remainder();\n      jsonTokenizerDone = true;\n\n      this.#snapshot = this.#snapshot || {};\n      this.#snapshot.snapshot = (JSON.parse(metaJSON) as HeapSnapshotHeader);\n    });\n    jsonTokenizer.write(json);\n    while (!jsonTokenizerDone) {\n      jsonTokenizer.write(await this.#fetchChunk());\n    }\n\n    this.#snapshot = this.#snapshot || {};\n    const nodes = await this.#parseArray(\n        '\"nodes\"', 'Loading nodes {PH1}%',\n        this.#snapshot.snapshot.meta.node_fields.length * this.#snapshot.snapshot.node_count);\n    this.#snapshot.nodes = nodes;\n\n    const edges = await this.#parseArray(\n        '\"edges\"', 'Loading edges {PH1}%',\n        this.#snapshot.snapshot.meta.edge_fields.length * this.#snapshot.snapshot.edge_count);\n    this.#snapshot.edges = edges;\n\n    if (this.#snapshot.snapshot.trace_function_count) {\n      const traceFunctionInfos = await this.#parseArray(\n          '\"trace_function_infos\"', 'Loading allocation traces {PH1}%',\n          this.#snapshot.snapshot.meta.trace_function_info_fields.length *\n              this.#snapshot.snapshot.trace_function_count);\n      this.#snapshot.trace_function_infos = traceFunctionInfos.asUint32ArrayOrFail();\n\n      const thisTokenEndIndex = await this.#findToken(':');\n      const nextTokenIndex = await this.#findToken('\"', thisTokenEndIndex);\n      const openBracketIndex = this.#json.indexOf('[');\n      const closeBracketIndex = this.#json.lastIndexOf(']', nextTokenIndex);\n      this.#snapshot.trace_tree = JSON.parse(this.#json.substring(openBracketIndex, closeBracketIndex + 1));\n      this.#json = this.#json.slice(closeBracketIndex + 1);\n    }\n\n    if (this.#snapshot.snapshot.meta.sample_fields) {\n      const samples = await this.#parseArray('\"samples\"', 'Loading samples');\n      this.#snapshot.samples = samples.asArrayOrFail();\n    }\n\n    if (this.#snapshot.snapshot.meta['location_fields']) {\n      const locations = await this.#parseArray('\"locations\"', 'Loading locations');\n      this.#snapshot.locations = locations.asArrayOrFail();\n    } else {\n      this.#snapshot.locations = [];\n    }\n\n    this.#progress.updateStatus('Loading strings');\n    const stringsTokenIndex = await this.#findToken('\"strings\"');\n    const bracketIndex = await this.#findToken('[', stringsTokenIndex);\n    this.#json = this.#json.slice(bracketIndex);\n    while (this.#buffer.length > 0 || !this.#done) {\n      this.#json += await this.#fetchChunk();\n    }\n    this.#parseStringsArray();\n  }\n}\n"],"names":["HeapSnapshotModel.HeapSnapshotModel.AllocationNodeCallers","HeapSnapshotModel.HeapSnapshotModel.AllocationStackFrame","HeapSnapshotModel.HeapSnapshotModel.SerializedAllocationNode","IntlMessageFormat.IntlMessageFormat","I18n.I18n.I18n","HeapSnapshotModel.HeapSnapshotModel.Edge","HeapSnapshotModel.HeapSnapshotModel.baseUnreachableDistance","HeapSnapshotModel.HeapSnapshotModel.Node","i18n.i18n.serializeUIString","HeapSnapshotModel.HeapSnapshotModel.HeapSnapshotProgressEvent","PromiseWithResolversPolyfill","Platform.TypedArrayUtilities.createBitVector","Platform.StringUtilities.createPlainTextSearchRegex","HeapSnapshotModel.HeapSnapshotModel.baseSystemDistance","toSortedPolyfill","Platform.ArrayUtilities.lowerBound","Platform.ArrayUtilities.DEFAULT_COMPARATOR","HeapSnapshotModel.HeapSnapshotModel.Samples","HeapSnapshotModel.HeapSnapshotModel.Location","HeapSnapshotModel.HeapSnapshotModel.AggregateForDiff","HeapSnapshotModel.HeapSnapshotModel.Diff","HeapSnapshotModel.HeapSnapshotModel.StaticData","Platform.MapUtilities.Multimap","HeapSnapshotModel.HeapSnapshotModel.ItemsRange","Platform.ArrayUtilities.sortRange","UIStrings","str_","i18n.i18n.registerUIStrings","i18n.i18n.getLazilyComputedLocalizedString","i18n.i18n.getLocalizedString","Platform.TypedArrayUtilities.createExpandableBigUint32Array","Platform.TypedArrayUtilities.createFixedBigUint32Array","TextUtils.TextUtils.BalancedJSONTokenizer"],"mappings":"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"}